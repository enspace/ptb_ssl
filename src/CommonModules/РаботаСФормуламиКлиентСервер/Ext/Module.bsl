
#Область ПрограммныйИнтерфейс_Подготовка

// Выводит результат расчета по формуле. Используется если есть ошибки
// в результате выполнения (НЕ РезультатРасчета.Выполнено)
//
// Параметры:
//	РезультатРасчета	- Структура - см. ВыполнитьРасчетФормул
//	Отказ				- Булево - признак для установки "Истина"
//
Процедура СообщитьРезультатРасчета(знач РезультатРасчета, Отказ = Ложь) Экспорт
	ТекстСообщения = РезультатРасчета.Текст;
	Для Каждого СтрокаПротокола Из РезультатРасчета.Протокол Цикл
		ТекстСообщения = ТекстСообщения + ?(ПустаяСтрока(ТекстСообщения), "", Символы.ПС)
			+ ?(СтрНачинаетсяС(ТекстСообщения, Символы.Таб), "", Символы.Таб)
			+ СтрокаПротокола.Текст;
	КонецЦикла;
	
	ВывестиСообщение(ТекстСообщения, Отказ);
КонецПроцедуры

// Выполняет преобразование коллекции в массив структур с данными по формулам
//
// Параметры:
//	Коллекция	- ДанныеФормыКоллекция, ТаблицаЗначений
//	ДопКолонки	- Строка - дополнительные колонки, необходимые для добавления в структуры
//
// Возвращаемое значение:
//   Соответствие
//		Ключ		- Строка - идентификатор + "_" + колонка
//		Значение	- Структура - основные колонки см. СтруктураФормулы(ДопКолонки)
//			СлужебныеДанные - Структура
//				Идентификатор		- Строка - нрег Идентификатор
//				Колонка				- Строка - нрег Колонка
//				Формула				- Строка - нрег Формула
//				ИмяПоказателя		- Строка - нрег ИмяПоказателя
//				ЭтоФормула			- Булево - признак, что это формула
//				СвязанныеПоказатели	- Строка - см. ПолучитьВсеПоказателиФормулы
//				Результат			- Неопределено, Число - результат расчета
// 
Функция ПодготовитьДанныеДляРасчета(знач Коллекция, знач ДопКолонки = "") Экспорт
	РезультатДанных = Новый Соответствие;
	
	Для Каждого СтрокаКоллекции Из Коллекция Цикл
		ДанныеФормулы = СтруктураФормулы(ДопКолонки);
		ЗаполнитьЗначенияСвойств(ДанныеФормулы, СтрокаКоллекции);
		
		СлужебныеДанные = ПодготовитьСлужебныеДанныеФормулы(ДанныеФормулы);
		
		ДанныеФормулы.Вставить("РезультатРасчета"	, Неопределено);
		ДанныеФормулы.Вставить("СлужебныеДанные"	, СлужебныеДанные);
		
		КлючФормулы = ПолучитьКлючФормулы(ДанныеФормулы.Идентификатор, ДанныеФормулы.Колонка);
		
		РезультатДанных.Вставить(КлючФормулы, ДанныеФормулы);
	КонецЦикла;	
	
	Возврат РезультатДанных;
КонецФункции

// Выполняет расчет по данным формул
//
// Параметры:
//	ДанныеРасчета	- Соответствие - см. ПодготовитьДанныеДляРасчета
//	Показатели		- Соответствие
//		Ключ		- Строка - имя показателя
//		Значение	- Число - значение показателя
//
// Возвращаемое значение:
//   Структура
//		Текст		- Строка - текст сообщения
//		Протокол	- Массив - массив структур с данными протокола
//			Текст			- Строка
//			Идентификатор	- Строка
//			Колонка			- Строка
//		Результат	- Соответствие
//			Ключ		- Строка - идентификатор + "_" + колонка
//			Значение	- Структура
//				Идентификатор	- Строка
//				Колонка			- Строка
//				Результат		- Неопределено, Число
//		Выполнено	- Булево
// 
Функция ВыполнитьРасчетФормул(знач ДанныеРасчета, знач Показатели = Неопределено) Экспорт
	Если НЕ ТипЗнч(Показатели) = Тип("Соответствие") Тогда
		Показатели = Новый Соответствие;
	КонецЕсли;
	
	// подготовим настройки
	НастройкиРасчета = ПодготовитьНастройкиРасчета(ДанныеРасчета);
	
	// проверим наличие циклических формул
	ЕстьЦиклическиеСсылки = ВыполнитьПроверкуЦиклическихСсылок(НастройкиРасчета);
	Если ЕстьЦиклическиеСсылки Тогда
		ТекстСообщения = НСтр("ru='Найдены циклические ссылки. Расчет итогов не выполнен.'");
		Возврат РезультатРасчетаФормул(ТекстСообщения, НастройкиРасчета.Протокол);
	КонецЕсли;
	
	// установим значения показателей пользователя
	Для Каждого КлючИЗначение Из Показатели Цикл
		НастройкиРасчета.КэшРасчетов.Вставить(НРег(КлючИЗначение.Ключ), КлючИЗначение.Значение);
	КонецЦикла;
	
	// выполним расчет показателей по формулам
	#Если ТонкийКлиент ИЛИ ТолстыйКлиентУправляемоеПриложение Тогда
		РезультатРасчета = ВыполнитьРасчетФормулРекурсивно(НастройкиРасчета, НастройкиРасчета.МассивФормулы);
	#Иначе
		РезультатРасчета = РаботаСФормуламиСлужебныйВызовСервера.ВыполнитьРасчетФормулРекурсивно(
			НастройкиРасчета,
			НастройкиРасчета.МассивФормулы);
	#КонецЕсли 
	
	Возврат РезультатРасчета;
КонецФункции

// Возвращает все показатели, используемые в формуле
//
// Параметры:
//	Формула - Строка - текст формулы
//
// Возвращаемое значение:
//   Массив - имена показателей в нижнем регистре
// 
Функция ПолучитьВсеПоказателиФормулы(знач Формула) Экспорт
	МассивОператоров = ПолучитьОператорыПоУбываниюДлины();
	
	Формула = СокрЛП(НРег(Формула));
	Для Каждого Оператор Из  МассивОператоров Цикл
		КлючПоиска			= НРег(Оператор.Оператор);
		ПроверитьОкончание	= СтроковыеФункцииКлиентСервер.ТолькоКириллицаВСтроке(КлючПоиска);
		
		КонПозиция = 1;
		НачПозиция = СтрНайти(Формула, КлючПоиска,, КонПозиция);
		Пока НачПозиция <> 0 Цикл
			КонПозиция = НачПозиция + СтрДлина(КлючПоиска);
			
			Если ПроверитьОкончание И ОператорЧастьСлова(Формула, НачПозиция, КонПозиция) Тогда
				Если КонПозиция >= СтрДлина(Формула) Тогда
					НачПозиция = 0;
				Иначе 
					НачПозиция = СтрНайти(Формула, КлючПоиска,, КонПозиция + 1);
				КонецЕсли;
				
				Продолжить;
			КонецЕсли;
			
			Формула = СтрШаблон("%1,%2", Лев(Формула, НачПозиция - 1), Сред(Формула, КонПозиция));
			
			Если КонПозиция + 1 < СтрДлина(Формула) Тогда
				НачПозиция = СтрНайти(Формула, КлючПоиска,, КонПозиция + 1);
			Иначе 
				НачПозиция = 0;
			КонецЕсли;
		КонецЦикла;
	КонецЦикла;
	
	Формула = СтрЗаменить(Формула, ".", ",");
	Формула = СтрЗаменить(Формула, "(", ",");
	Формула = СтрЗаменить(Формула, ")", ",");
	
	МассивПодстрок = СтрРазделить(Формула, ",", Ложь);
	
	МассивПоказателей = Новый Массив;
	Для Каждого ИмяПоказателя Из МассивПодстрок Цикл
		ИмяПоказателя = СокрЛП(ИмяПоказателя);
		
		Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ИмяПоказателя) Тогда
			Продолжить;
		КонецЕсли;
		
		Если ПустаяСтрока(ИмяПоказателя) ИЛИ ИмяПоказателя = "," Тогда
			Продолжить;
		ИначеЕсли МассивПоказателей.Найти(ИмяПоказателя) <> Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		МассивПоказателей.Добавить(ИмяПоказателя);
	КонецЦикла;
	
	Возврат МассивПоказателей;
КонецФункции

// Возвращает строковое представление формулы или ручного значения
//	Для формулы: fx=Формула
//	Для значения: Зн=РучноеЗначение
//
// Параметры:
//	ДанныеФормулы - Структура - данные формулы, требуемые колонки:
//		СпособРасчета,РучноеЗначение,Формула 
//
// Возвращаемое значение:
//   Строка
//
Функция ПолучитьРасчетПредставление(знач ДанныеФормулы) Экспорт
	Если ДанныеФормулы.СпособРасчета = ПредопределенноеЗначение("Перечисление.СпособыРасчетаПоказателяФормулы.РучнойВвод") Тогда
		Возврат СтрШаблон("Зн= %1", Формат(ДанныеФормулы.РучноеЗначение, "ЧН=0; ЧГ="));
	ИначеЕсли ДанныеФормулы.СпособРасчета = ПредопределенноеЗначение("Перечисление.СпособыРасчетаПоказателяФормулы.Формула") Тогда
		Возврат СтрШаблон("fx= %1", СокрЛП(ДанныеФормулы.Формула));
	Иначе 
		Возврат "";
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Проверки

// Выполняет проверку наличия циклических ссылок и выдает сообщение
//
// Параметры:
//	ДанныеРасчета	- Соответствие - см. ПодготовитьДанныеДляРасчета
//
// Возвращаемое значение:
//   Булево
// 
Функция ПроверитьЦиклическиеСсылки(знач ДанныеРасчета, Отказ = Ложь) Экспорт
	НастройкиРасчета = ПодготовитьНастройкиРасчета(ДанныеРасчета);
	
	ЕстьЦиклическиеСсылки = ВыполнитьПроверкуЦиклическихСсылок(НастройкиРасчета);
	Если НЕ ЕстьЦиклическиеСсылки Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ТекстСообщения = НСтр("ru='Найдены циклические ссылки:'");
	
	Для Каждого СтрокаПротокола Из НастройкиРасчета.Протокол Цикл
		ТекстСообщения = ТекстСообщения + ?(ПустаяСтрока(ТекстСообщения), "", Символы.ПС + Символы.Таб)
			+ "- " + СтрокаПротокола.Текст;
	КонецЦикла;
	
	ВывестиСообщение(ТекстСообщения, Отказ);
	
	Возврат Истина;
КонецФункции

// Выполняет проверку имени показателя для возможности применения
//
// Параметры:
//	ИмяПоказателя	- Строка - имя показателя для проверки
//	Показатели		- Массив - имена использованных показателей в нижнем регистре
//		см. ПолучитьВсеПоказателиФормулы
//	Отказ			- Булево - переменная для возврата Истина, если проверка не пройдена
//
// Возвращаемое значение:
//   Структура
//		ЕстьОшибки		- Булево - есть ошибки в процессе проверки
//		ТекстСообщения	- Строка - текст результата проверки
//
Функция ПроверитьИмяПоказателя(знач ИмяПоказателя, знач Показатели = Неопределено, Отказ = Ложь) Экспорт
	РезультатПроверки = Новый Структура("ЕстьОшибки, ТекстСообщения",
		Ложь,
		"");
	
	// разрешенные символы
	РазрешенныеСимволы	= "abcdefghijklmnopqrstuvwxyz0123456789_";
	ПроверкаПройдена	= СтроковыеФункцииКлиентСерверРФ.ТолькоКириллицаВСтроке(НРег(ИмяПоказателя), Ложь, РазрешенныеСимволы);
	Если НЕ ПроверкаПройдена Тогда
		РезультатПроверки.ЕстьОшибки		= Истина;
		РезультатПроверки.ТекстСообщения	= НСтр("ru='Имя показателя содержит запрещенные символы.'");
		Возврат РезультатПроверки;
	КонецЕсли;
	
	// попытка использовать как ключ
	Попытка
		СтруктураДанных = Новый Структура(ИмяПоказателя);
	Исключение
		РезультатПроверки.ЕстьОшибки		= Истина;
		РезультатПроверки.ТекстСообщения	= НСтр("ru='Имя показателя содержит запрещенные символы.'");;
		Возврат РезультатПроверки;
	КонецПопытки;
	
	// наличие в сметных показателях
	ДанныеПоказателя = Показатели.Получить(НРег(ИмяПоказателя));
	Если НЕ ДанныеПоказателя = Неопределено Тогда
		РезультатПроверки.ЕстьОшибки		= Истина;
		РезультатПроверки.ТекстСообщения	= СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Показатель с именем ""%1"" уже существует.'"), ИмяПоказателя);
			
		Возврат РезультатПроверки; 
	КонецЕсли; 
	
	// имя показателя не должно равняться логическим операторам
	МассивОператоров = ЛогическиеОператоры();
	Для Каждого Оператор Из МассивОператоров Цикл
		Если НЕ НРег(Оператор.Оператор) = НРег(ИмяПоказателя) Тогда
			Продолжить;
		КонецЕсли;
		
		РезультатПроверки.ЕстьОшибки		= Истина;
		РезультатПроверки.ТекстСообщения	= СтрШаблон(НСтр("ru='Имя показателя не может быть равно ""%1"".'"), Оператор.Оператор);
		Возврат РезультатПроверки;
	КонецЦикла;
	
	Возврат РезультатПроверки;
КонецФункции

// Выполняет проверку формулы на наличие ошибок
// Основная проверка - наличие чисел, с разделителем целой и дробной частью через запятую
//
// Параметры:
//	Формула	- Строка - текст формулы для проверки
//
// Возвращаемое значение:
//   Структура
//		ЕстьОшибки		- Булево - признак наличия ошибки в формуле
//		ТекстСообщения	- Строка - описание текста ошибки
//		Формула			- Строка - измененная формула, после "," в числах подставлены пробелы
//
Функция ПроверитьНаличиеОшибокФормулы(знач Формула) Экспорт
	СтрФормула	= СокрЛП(Формула);
	Подстроки	= СтрРазделить(СтрФормула, ",");
	
	ЕстьОшибки = Ложь;
	Для Индекс = 0 По Подстроки.ВГраница() Цикл
		Если Индекс = 0 Тогда
			Продолжить;
		КонецЕсли;
		
		Подстрока_0 = ?(Индекс = 0, "", Подстроки[Индекс-1]);
		Подстрока_1 = Подстроки[Индекс];
		
		ПоследнийСлева	= Прав(Подстрока_0, 1);
		ПервыйСправа	= Лев(Подстрока_1, 1);
		
		Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ПоследнийСлева + ПервыйСправа) Тогда
			ЕстьОшибки = Истина;
			Подстроки[Индекс] = " " + Подстрока_1;
		КонецЕсли;
	КонецЦикла;
	
	ТекстСообщения = НСтр("ru='В формуле были найдены ошибки при использовании запятой (,). Способы устранения:
		|	- проверьте использование дробных чисел. Разделитель между целой и дробной частью должен быть точкой (.);
		|	- при использовании запятой как части оператора поставьте пробел между запятой и числами слева и/или справа'");
	
	Возврат Новый Структура("ЕстьОшибки, ТекстСообщения, Формула",
		ЕстьОшибки,
		ТекстСообщения,
		СтрСоединить(Подстроки, ","));
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_РедактированиеПоказатели

// Добавляет группу показателей в массив
//	Массив используется для передачи в качестве параметра в методе вызова формы
//	редактирования формулы. Подробнее см. РаботаСФормуламиКлиент.ПараметрыРедактирования
//
// Параметры:
//	Показатели	- Структура - коллекция для добавления структуры группы
//	ИмяГруппы	- Строка - уникальное имя, должно отвечать требованиям ключа структуры
//	Описание	- Строка - представление группы для пользователя
//
Процедура ДобавитьГруппуПоказателей(знач Показатели, знач ИмяГруппы, знач Описание) Экспорт
	Если НЕ ТипЗнч(Показатели) = Тип("Структура") Тогда
		Показатели = Новый Структура;
	КонецЕсли;
	
	СтруктураГруппы = Новый Структура("Тип,Элементы,ИмяГруппы,Описание",
		"Группа",
		Новый Структура,
		ИмяГруппы,
		Описание);
		
	Показатели.Вставить(ИмяГруппы, СтруктураГруппы);
КонецПроцедуры

// Добавляет показатель в группу. Все имена показателей должны быть уникальны вне зависимости
// от расположения в группе, поскольку имена используются в формулах
//
// Параметры:
//	Группа 			- Структура - группа, добавленная методом ДобавитьГруппуПоказателей
//	ИмяПоказателя	- Строка - уникальное имя, должно отвечать требованиям ключа структуры
//	Описание	- Строка - представление группы для пользователя
//
Процедура ДобавитьПоказательВГруппу(знач Группа, знач ИмяПоказателя, знач Описание) Экспорт
	СтруктураПоказателя = Новый Структура("Тип,Показатель,Описание",
		"Показатель",
		ИмяПоказателя,
		Описание);
		
	Группа.Элементы.Вставить(ИмяПоказателя, СтруктураПоказателя);
КонецПроцедуры

#КонецОбласти 

#Область ПрограммныйИнтерфейс_Интерфейс

Функция АрифметическиеОператоры() Экспорт
	
	МассивОпераций = Новый Массив;
	
	ДобавитьОператор(МассивОпераций, "А", "+", НСтр("ru='Сложение'")			, " + ",, НСтр("ru='Операция сложения'"));
	ДобавитьОператор(МассивОпераций, "А", "-", НСтр("ru='Вычитание'")			, " - ",, НСтр("ru='Операция вычитания'"));
	ДобавитьОператор(МассивОпераций, "А", "*", НСтр("ru='Умножение'")			, " * ",, НСтр("ru='Операция умножения'"));
	ДобавитьОператор(МассивОпераций, "А", "/", НСтр("ru='Деление'")				, " / ",, НСтр("ru='Операция деления'"));
	ДобавитьОператор(МассивОпераций, "А", "%", НСтр("ru='Остаток от деления'")	, " % ",, НСтр("ru='Вычисление остатка от деления'"));
	
	Возврат МассивОпераций;
	
КонецФункции

Функция ЛогическиеОператоры() Экспорт
	
	МассивОпераций = Новый Массив;
	
	ДобавитьОператор(МассивОпераций, "Л" , "="		, НСтр("ru='Равно'")			, " = "		,, НСтр("ru='А равно Б'") );
	ДобавитьОператор(МассивОпераций, "Л" , "<>"		, НСтр("ru='Не равно'")			, " <> "	,, НСтр("ru='А не равно Б'") );
	ДобавитьОператор(МассивОпераций, "Л" , ">"		, НСтр("ru='Больше'")			, " > "		,, НСтр("ru='А больше Б'") );
	ДобавитьОператор(МассивОпераций, "Л" , ">="		, НСтр("ru='Больше или равно'")	, " >= "	,, НСтр("ru='А больше или равно'") );
	ДобавитьОператор(МассивОпераций, "Л" , "<"		, НСтр("ru='Меньше'")			, " < "		,, НСтр("ru='А меньше Б'") );
	ДобавитьОператор(МассивОпераций, "Л" , "<="		, НСтр("ru='Меньше или равно'")	, " <= "	,, НСтр("ru='А меньше или равно Б'") );
	ДобавитьОператор(МассивОпераций, "Л0", "И"		, НСтр("ru='И'")				, " И "		,, НСтр("ru='Условие И (конъюкция)'") );
	ДобавитьОператор(МассивОпераций, "Л0", "ИЛИ"	, НСтр("ru='ИЛИ'")				, " ИЛИ "	,, НСтр("ru='Условие ИЛИ (дизъюкция)'") );
	ДобавитьОператор(МассивОпераций, "Л0", "НЕ"		, НСтр("ru='НЕ'")				, " НЕ "	,, НСтр("ru='Логические отрицание'") );
	ДобавитьОператор(МассивОпераций, "Л0", "ИСТИНА"	, НСтр("ru='ИСТИНА'")			, " ИСТИНА ",, НСтр("ru='Истинное значение (да)'") );
	ДобавитьОператор(МассивОпераций, "Л0", "ЛОЖЬ"	, НСтр("ru='ЛОЖЬ'")				, " ЛОЖЬ "	,, НСтр("ru='Ложное значение (нет)'") );
	
	Возврат МассивОпераций;
	
КонецФункции

Функция МатематическиеОператоры() Экспорт
	
	МассивОпераций = Новый Массив;
	
	ДобавитьОператор(МассивОпераций, "М", "ОКР(", НСтр("ru='Округление'"),
		" Окр({Значение}, {Точность}) ", Истина,
		НСтр("ru='Округление вверх (1.5 как 2).'"),
		НСтр("ru='	{Значение} - исходное число;
		|	{Точность} - число знаков дробной части, до которых производится округление. Если параметр отрицательный, "
			+ "то число округляется до соответствующего разряда в целой части, начиная с младших разрядов'"));
		
	ДобавитьОператор(МассивОпераций, "М", "ЦЕЛ(", НСтр("ru='Целая часть'"),
		" Цел({Значение}) ", Истина,
		НСтр("ru='Вычисляет целую часть переданного числа, полностью отсекая дробную часть'"),
		НСтр("ru='	{Значение} - исходное число'"));
		
	ДобавитьОператор(МассивОпераций, "М", "МАКС(", НСтр("ru='Максимум'"),
		" Макс({Значение1}, {Значение2}) ", Истина,
		НСтр("ru='Определяет максимальное значение из полученных параметров (количество значений может быть более 2)'"),
		НСтр("ru='	{Значение1}, {Значение2} - перечень значений для сравнения'"));
		
	ДобавитьОператор(МассивОпераций, "М", "МИН(", НСтр("ru='Минимум'"),
		" Мин({Значение1}, {Значение2}) ", Истина,
		НСтр("ru='Определяет минимальное значение из полученных параметров (количество значений может быть более 2)'"),
		НСтр("ru='	{Значение1}, {Значение2} - перечень значений для сравнения'"));
		
	ДобавитьОператор(МассивОпераций, "М", "?(", НСтр("ru='Условие'"),
		" ?({Условие}, {ВыражениеИстина}, {ВыражениеЛожь}) ", Истина,
		НСтр("ru='Позволяет вычислить одно из двух заданных выражений в зависимости от результата вычисления логического выражения'"),
		НСтр("ru='	{Условие} - результат вычисления которого определяет одно из результирующих выражений, которые будут вычислены
		|	{ВыражениеИстина} - выражение, если результат условия = Истина
		|	{ВыражениеЛожь} - выражение, если результат условия = Ложь'"));
	
	ДобавитьОператор(МассивОпераций, "М", "ПРЕДОПРЕДЕЛЕННОЕЗНАЧЕНИЕ(", НСтр("ru='Предопределенное значение'"),
		" ПредопределенноеЗначение({Значение}) ", Истина,
		НСтр("ru='Возвращает ссылку на предопределенный элемент из предопределенных данных'"),
		НСтр("ru='	{Значение} - содержит полный путь до предопределенного значения, включая имя самого значения'"));
	
	ДобавитьОператор(МассивОпераций, "М", "ЗНАЧЕНИЕЗАПОЛНЕНО(", НСтр("ru='Значение заполнено'"),
		" ЗначениеЗаполнено({Значение}) ", Истина,
		НСтр("ru='Функция проверяет, отличается ли переданное значение от значения по умолчанию того же типа'"),
		НСтр("ru='	{Значение} - значение для проверки'"));
	
	Возврат МассивОпераций;
	
КонецФункции

Функция СтроковыеОператоры() Экспорт
	
	МассивОпераций = Новый Массив;
	
	ДобавитьОператор(МассивОпераций, "С", "СТРНАЙТИ(", НСтр("ru='Поиск по строке'"),
		" СтрНайти({Значение}, {Поиск}) ", Истина,
		НСтр("ru='Находит первое вхождение искомой строки как подстроки в исходной строке. Сравнение выполняется с учетом регистра'"),
		НСтр("ru='	{Значение} - исходная строка
		|	{Поиск} - искомая подстрока'"));
		
	ДобавитьОператор(МассивОпераций, "С", "СТРНАЧИНАЕТСЯС(", НСтр("ru='Начинается с'"),
		" СтрНачинаетсяС({Значение}, {Начало}) ", Истина,
		НСтр("ru='Определяет, что строка начинается с указанной подстроки. Определение выполняется с учетом регистра'"),
		НСтр("ru='	{Значение} - исходная строка
		|	{Начало} - предполагаемое начало строки'"));
		
	ДобавитьОператор(МассивОпераций, "С", "СТРЗАКАНЧИВАЕТСЯНА(", НСтр("ru='Заканчивается на'"),
		" СтрЗаканчиваетсяНа({Значение}, {Окончание}) ", Истина,
		НСтр("ru='Определяет, заканчивается ли строка указанной подстрокой. Определение выполняется с учетом регистра'"),
		НСтр("ru='	{Значение} - исходная строка
		|	{Окончание} - предполагаемое окончание строки'"));
	
	ДобавитьОператор(МассивОпераций, "С", "СТРДЛИНА(", НСтр("ru='Длина строки'"),
		" СтрДлина({Значение}) ", Истина,
		НСтр("ru='Получает количество символов в строке'"),
		НСтр("ru='	{Значение} - исходная строка'"));
	
	ДобавитьОператор(МассивОпераций, "С", "СОКРЛ(", НСтр("ru='Удалить пробелы слева'"),
		" СокрЛ({Значение}) ", Истина,
		НСтр("ru='Отсекает незначащие символы, стоящие слева от первого значащего символа в строке'"),
		НСтр("ru='	{Значение} - исходная строка'"));
	
	ДобавитьОператор(МассивОпераций, "С", "СОКРП(", НСтр("ru='Удалить пробелы справа'"),
		" СокрП({Значение}) ", Истина,
		НСтр("ru='Отсекает незначащие символы, стоящие справа от последнего значащего символа в строке'"),
		НСтр("ru='	{Значение} - исходная строка'"));
	
	ДобавитьОператор(МассивОпераций, "С", "СОКРЛП(", НСтр("ru='Удалить пробелы по обоим сторонам'"),
		" СокрЛП({Значение}) ", Истина,
		НСтр("ru='Отсекает незначащие символы, стоящие слева от первого значащего символа в строке, и пробелы, стоящие справа от последнего значащего символа в строке'"),
		НСтр("ru='	{Значение} - исходная строка'"));
	
	ДобавитьОператор(МассивОпераций, "С", "ЛЕВ(", НСтр("ru='Первые символы слева'"),
		" Лев({Значение}, {КолСимволов}) ", Истина,
		НСтр("ru='Выбирает первые слева символы строки'"),
		НСтр("ru='	{Значение} - исходная строка
		|	{КолСимволов} - количество выбираемых символов'"));
	
	ДобавитьОператор(МассивОпераций, "С", "ПРАВ(", НСтр("ru='Последние символы справа'"),
		" Прав({Значение}, {КолСимволов}) ", Истина,
		НСтр("ru='Выбирает последние справа символы строки'"),
		НСтр("ru='	{Значение} - исходная строка
		|	{КолСимволов} - количество выбираемых символо'"));
	
	ДобавитьОператор(МассивОпераций, "С", "СРЕД(", НСтр("ru='Подстрока'"),
		" Сред({Значение}, {НачСимвол}, {КолСимволов}) ", Истина,
		НСтр("ru='Выбирает строку символов, начиная с символа {НачСимвол}, общим количеством {КолСимволов}'"),
		НСтр("ru='	{Значение} - исходная строка
		|	{НачСимвол} - начальный номер символа, с которого начинается выборка
		|	{КолСимволов} - количество выбираемых символов. Если параметр не указан, то выбираются символы до конца строки'"));
	
	ДобавитьОператор(МассивОпераций, "С", "НРЕГ(", НСтр("ru='Перевод в нижний регистр'"),
		" НРег({Значение}) ", Истина,
		НСтр("ru='Преобразует все символы строки в нижний регистр'"),
		НСтр("ru='	{Значение} - исходная строка'"));
	
	ДобавитьОператор(МассивОпераций, "С", "ВРЕГ(", НСтр("ru='Перевод в верхний регистр'"),
		" ВРег({Значение}) ", Истина,
		НСтр("ru='Преобразует все символы строки в верхний регистр'"),
		НСтр("ru='	{Значение} - исходная строка'"));
	
	Возврат МассивОпераций;
	
КонецФункции

#КонецОбласти 

#Область СлужебныйПрограммныйИнтерфейс

Функция ВыполнитьРасчетФормулРекурсивно(знач Настройки, знач МассивКлючей, знач Контроль = -1) Экспорт
	// если массив ключей пуст или количество = предыдущей итерации тогда завершаем выполнение
	Если НЕ ТипЗнч(МассивКлючей) = Тип("Массив") ИЛИ МассивКлючей.Количество() = 0 Тогда
		Возврат РезультатРасчетаФормул(НСтр("ru='Расчет выполнен успешно'"),
			Настройки.Протокол,
			Настройки.Результат,
			Истина);
	ИначеЕсли МассивКлючей.Количество() = Контроль Тогда
		ТекстСообщения = НСтр("ru='Ошибка при расчете показателя'");
		Для Каждого КлючФормулы Из МассивКлючей Цикл
			ДанныеФормулы = Настройки.Данные.Получить(КлючФормулы);
			ДобавитьСообщениеВПротокол(Настройки, ТекстСообщения, ДанныеФормулы);
		КонецЦикла;
		
		Возврат РезультатРасчетаФормул(НСтр("ru='При расчете формул произошла ошибка'"),
			Настройки.Протокол,
			Неопределено,
			Ложь);
	КонецЕсли;
	
	// данные для следующей итерации расчетов
	НовыйКонтроль	= МассивКлючей.Количество();
	ОстаткиКлючей	= Новый Массив;
	
	// выполняем обход и расчет всех показателей
	Для Каждого КлючФормулы Из МассивКлючей Цикл
		// проверим возможность расчета по ключу
		Если НЕ ПроверитьВозможностьРасчетаКлюча(Настройки, КлючФормулы) Тогда
			ОстаткиКлючей.Добавить(КлючФормулы);
			Продолжить;
		КонецЕсли;
		
		Результат = ВыполнитьРасчетКлюча(Настройки, КлючФормулы);
		Если НЕ Результат Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	// продолжаем расчет по оставшимся ключам
	Возврат ВыполнитьРасчетФормулРекурсивно(Настройки, ОстаткиКлючей, НовыйКонтроль);
КонецФункции

Функция ПодготовитьНастройкиРасчета(знач ДанныеРасчета) Экспорт
	КэшИменПоказателей	= Новый Соответствие;
	КэшРасчетов			= Новый Соответствие;
	МассивФормулы		= Новый Массив;
	
	Для Каждого КлючИЗначение Из ДанныеРасчета Цикл
		КлючФормулы		= КлючИЗначение.Ключ;
		ДанныеФормулы	= КлючИЗначение.Значение;
		СлужебныеДанные	= ДанныеФормулы.СлужебныеДанные;
		
		Если ДанныеФормулы.ЭтоПоказатель И ЗначениеЗаполнено(ДанныеФормулы.ИмяПоказателя) Тогда
			КэшИменПоказателей.Вставить(СлужебныеДанные.ИмяПоказателя, КлючФормулы);
		КонецЕсли;
		
		Если НЕ СлужебныеДанные.ЭтоФормула Тогда
			КэшРасчетов.Вставить(СлужебныеДанные.ИмяПоказателя, ДанныеФормулы.РучноеЗначение);
		Иначе 
			МассивФормулы.Добавить(КлючФормулы);
		КонецЕсли;
	КонецЦикла;
	
	Настройки = Новый Структура;
	Настройки.Вставить("Протокол"		, Новый Массив);
	Настройки.Вставить("Данные"			, ДанныеРасчета);
	Настройки.Вставить("КэшИменаКлючи"	, КэшИменПоказателей);
	Настройки.Вставить("КэшРасчетов"	, КэшРасчетов);
	Настройки.Вставить("МассивФормулы"	, МассивФормулы);
	Настройки.Вставить("Результат"		, Новый Соответствие);
	
	Возврат Настройки;
КонецФункции
 
Функция СтруктураФормулы(знач ДопКолонки = "") Экспорт
	Структура = Новый Структура("Идентификатор, Колонка, Формула, ЭтоПоказатель, ИмяПоказателя, ОписаниеПоказателя"
		+ ", НеОкруглять, НеОтрицательное, ТочностьОкругления, РучноеЗначение, СпособРасчета, Показатель"
		+ ", РасчетПредставление, Значение" + ?(ПустаяСтрока(ДопКолонки), "", ",") + ДопКолонки);
	Структура.Вставить("type", "ДанныеФормулы");
	Возврат Структура;
КонецФункции

Функция ПолучитьКлючФормулы(знач Идентификатор, знач Колонка) Экспорт
	Если НЕ ТипЗнч(Идентификатор) = Тип("Строка") Тогда
		Идентификатор = "";
	КонецЕсли;
	Если НЕ ТипЗнч(Колонка) = Тип("Строка") Тогда
		Колонка = "";
	КонецЕсли;
	
	Возврат СтрШаблон("%1_%2", НРег(Идентификатор), НРег(Колонка));
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ДобавитьОператор(Коллекция, знач ТипОператора, знач Оператор, знач Описание, знач Подстановка, знач ЕстьОкончание = Ложь, знач Подсказка = "", знач Параметры = "")
	СтруктураОператора = Новый Структура("Оператор,Тип,Описание,Подстановка,ЕстьОкончание,Подсказка,Параметры",
		Оператор,
		ТипОператора,
		Описание,
		Подстановка,
		ЕстьОкончание,
		Подсказка,
		Параметры);
		
	Коллекция.Добавить(СтруктураОператора);
КонецПроцедуры

Функция ПроверитьВозможностьРасчетаКлюча(знач Настройки, знач КлючФормулы)
	ДанныеФормулы = Настройки.Данные.Получить(КлючФормулы);
	Если ДанныеФормулы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	СлужебныеДанные = ДанныеФормулы.СлужебныеДанные;
	Для Каждого ИмяПоказателя Из СлужебныеДанные.СвязанныеПоказатели Цикл
		РезультатРасчета = Настройки.КэшРасчетов.Получить(ИмяПоказателя);
		Если РезультатРасчета = Неопределено Тогда
			Возврат Ложь;
		КонецЕсли;
	КонецЦикла;
	
	Возврат Истина;
КонецФункции

Функция ВыполнитьРасчетКлюча(знач Настройки, знач КлючФормулы)
	ДанныеФормулы = Настройки.Данные.Получить(КлючФормулы);
	Если ДанныеФормулы = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	// данные настройки
	КэшРасчетов = Настройки.КэшРасчетов;
	Результаты	= Настройки.Результат;
	
	// служебные данные формулы
	СлужебныеДанные = ДанныеФормулы.СлужебныеДанные;
	
	// параметры подготовки значения
	НеОкруглять			= ДанныеФормулы.НеОкруглять;
	ТочностьОкругления	= ДанныеФормулы.ТочностьОкругления;
	НеОтрицательное		= ДанныеФормулы.НеОтрицательное;
	
	ТекстПоказателей = "";
	Для Каждого КлючИЗначение Из КэшРасчетов Цикл
		Значение	= КлючИЗначение.Значение;
		СтрЗначение = ?(НЕ ТипЗнч(Значение) = Тип("Число"), "0", Формат(Значение, "ЧРД=.; ЧН=0; ЧГ="));
		
		ТекстПоказателей = ТекстПоказателей + ?(ПустаяСтрока(ТекстПоказателей), "", "
		|") + КлючИЗначение.Ключ + " = " + СтрЗначение + ";";
	КонецЦикла;
	
	ТекущееЗначение = 0;
	
	Попытка
		Выполнить ТекстПоказателей + "
		|	ТекущееЗначение = " + СлужебныеДанные.Формула + ";";
	Исключение
		ВызватьИсключение СтрШаблон(НСтр("ru='Ошибка при рекурсивном вычислении показателя ""%1"";
			|	Формула: ""%2"";
			|	Ошибка: %3.'"),
			ДанныеФормулы.ИмяПоказателя,
			ДанныеФормулы.Формула,
			КраткоеПредставлениеОшибки(ИнформацияОбОшибке()));
	КонецПопытки;
	
	Если НЕ ТипЗнч(ТекущееЗначение) = Тип("Число") Тогда
		ТекущееЗначение = 0;
	КонецЕсли;
	
	Если НеОкруглять = Ложь И ТипЗнч(ТочностьОкругления) = Тип("Число") Тогда
		ТекущееЗначение = Окр(ТекущееЗначение, ТочностьОкругления);
	КонецЕсли;
	
	Если НеОтрицательное = Истина Тогда
		ТекущееЗначение = Макс(ТекущееЗначение, 0);
	КонецЕсли;
	
	Если ДанныеФормулы.ЭтоПоказатель И НЕ ПустаяСтрока(СлужебныеДанные.ИмяПоказателя) Тогда
		Настройки.КэшРасчетов.Вставить(СлужебныеДанные.ИмяПоказателя, ТекущееЗначение);
	КонецЕсли;
		
	СтруктураРезультата = Новый Структура("Идентификатор,Колонка,Результат",
		ДанныеФормулы.Идентификатор,
		ДанныеФормулы.Колонка, 
		ТекущееЗначение);
		
	Настройки.Результат.Вставить(КлючФормулы, СтруктураРезультата);
	
	Возврат Истина;
КонецФункции

Функция ВыполнитьПроверкуЦиклическихСсылок(знач Настройки)
	ЕстьОшибки = Ложь;
	
	КэшСтатусов = Новый Соответствие;
	Для Каждого КлючИЗначение Из Настройки.Данные Цикл
		КлючФормулы		= КлючИЗначение.Ключ;
		ДанныеФормулы	= КлючИЗначение.Значение;
		
		Если НЕ ДанныеФормулы.ЭтоПоказатель = Истина Тогда
			Продолжить;
		КонецЕсли;
		
		СлужебныеДанные = ДанныеФормулы.СлужебныеДанные;
		
		КэшСтатусов.Вставить(СлужебныеДанные.ИмяПоказателя, Новый Структура("Ошибка, Показатели", Истина, ""));
		Результат = ПроверитьПересечениеСсылок(Настройки, ДанныеФормулы, КэшСтатусов);
		КэшСтатусов.Вставить(СлужебныеДанные.ИмяПоказателя, Результат);
		
		Если Результат.Ошибка = Истина Тогда
			ЕстьОшибки = Истина;
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат ЕстьОшибки;
КонецФункции

Функция ПроверитьПересечениеСсылок(знач Настройки, знач ДанныеФормулы, знач КэшСтатусов)
	РезультатПроверки = Новый Структура("Ошибка, Показатели", Ложь, "");
	
	ЕстьОшибки			= Ложь;
	ПоказателиОшибок	= "";
	
	СлужебныеДанные = ДанныеФормулы.СлужебныеДанные;
	Для Каждого ИмяПоказателя Из СлужебныеДанные.СвязанныеПоказатели Цикл
		КлючФормулы			= Настройки.КэшИменаКлючи.Получить(ИмяПоказателя);
		ДанныеПоказателя	= Настройки.Данные.Получить(КлючФормулы);
		
		РезультатПоказателя = КэшСтатусов.Получить(ИмяПоказателя);
		Если РезультатПоказателя = Неопределено Тогда
			РезультатПоказателя = Новый Структура("Ошибка, Показатели", Ложь, "");
			Если НЕ ДанныеПоказателя = Неопределено Тогда
				КэшСтатусов.Вставить(ИмяПоказателя, Новый Структура("Ошибка, Показатели", Истина, ""));
				Результат = ПроверитьПересечениеСсылок(Настройки, ДанныеПоказателя, КэшСтатусов);
				
				ЗаполнитьЗначенияСвойств(РезультатПоказателя, Результат);
			КонецЕсли;
			
			КэшСтатусов.Вставить(ИмяПоказателя, РезультатПоказателя);
		КонецЕсли;
		
		ЕстьОшибки = ?(РезультатПоказателя.Ошибка, Истина, ЕстьОшибки);
		Если РезультатПоказателя.Ошибка Тогда
			ПоказателиОшибок = ПоказателиОшибок + ?(ПустаяСтрока(ПоказателиОшибок), "", "," ) + ДанныеПоказателя.ИмяПоказателя;
		КонецЕсли;
	КонецЦикла;
	
	РезультатПроверки.Ошибка		= ЕстьОшибки;
	РезультатПроверки.Показатели	= ПоказателиОшибок;
	
	Если ЕстьОшибки Тогда
		ТекстСообщения = СтроковыеФункцииКлиентСервер.ПодставитьПараметрыВСтроку(
			НСтр("ru='Элемент формулы ""%1"" содержит некорректные ссылки (%2).'"),
			ДанныеФормулы.ИмяПоказателя,
			ПоказателиОшибок);
		ДобавитьСообщениеВПротокол(Настройки, ТекстСообщения, ДанныеФормулы.Идентификатор);
	КонецЕсли;
	
	Возврат РезультатПроверки;
КонецФункции

Функция ПодготовитьСлужебныеДанныеФормулы(знач ДанныеФормулы)
	СпособРасчетаФормула = ПредопределенноеЗначение("Перечисление.СпособыРасчетаПоказателяФормулы.Формула");
	
	СлужебныеДанные = Новый Структура("Идентификатор,Колонка,Формула,ИмяПоказателя,ЭтоФормула,СвязанныеПоказатели"
		+ ",Результат");
	
	СлужебныеДанные.Идентификатор		= НРег(ДанныеФормулы.Идентификатор);
	СлужебныеДанные.Колонка				= НРег(ДанныеФормулы.Колонка);
	СлужебныеДанные.Формула				= НРег(ДанныеФормулы.Формула);
	СлужебныеДанные.ИмяПоказателя		= НРег(ДанныеФормулы.ИмяПоказателя);
	СлужебныеДанные.ЭтоФормула			= (ДанныеФормулы.СпособРасчета = СпособРасчетаФормула);
	СлужебныеДанные.СвязанныеПоказатели	= ПолучитьВсеПоказателиФормулы(ДанныеФормулы.Формула);
	
	Возврат СлужебныеДанные;
КонецФункции

Функция РезультатРасчетаФормул(знач Текст, знач Протокол, знач Результат = Неопределено, знач Выполнено = Ложь)
	Возврат Новый Структура("Текст, Протокол, Результат, Выполнено",
		Текст,
		Протокол,
		Результат,
		Выполнено);
КонецФункции

Функция ДобавитьСообщениеВПротокол(знач Настройки, знач Текст, знач ДанныеФормулы = Неопределено)
	СтруктураЗаписи = Новый Структура("Текст,Идентификатор,Колонка", "", "", "");
	СтруктураЗаписи.Текст = Текст;
	
	ТипДанныеФормулы = "";
	Если ТипЗнч(ДанныеФормулы) = Тип("Структура")
		И ДанныеФормулы.Свойство("type", ТипДанныеФормулы)
		И ТипДанныеФормулы = "ДанныеФормулы" тогда
		
		СтруктураЗаписи.Идентификатор	= ДанныеФормулы.Идентификатор;
		СтруктураЗаписи.Колонка			= ДанныеФормулы.Колонка;
	КонецЕсли;
	
	Настройки.Протокол.Добавить(СтруктураЗаписи);
КонецФункции

Функция ВывестиСообщение(знач ТекстСообщения, Отказ = Ложь, знач КлючДанных = Неопределено, знач Поле = "", знач ПутьКДанным = "")
	#Если Сервер Тогда
	    ОбщегоНазначения.СообщитьПользователю(ТекстСообщения, КлючДанных, Поле, ПутьКДанным, Отказ);
	#Иначе
		ОбщегоНазначенияКлиент.СообщитьПользователю(ТекстСообщения, КлючДанных, Поле, ПутьКДанным, Отказ);
	#КонецЕсли
КонецФункции
	
#КонецОбласти

#Область ПостроениеДереваФормулы

// НЕ РАБОТАЕТ
Функция РазобратьФормулу(знач Формула)
	ДеревоФормулы = Новый Массив;
	
	НРегФормула = СокрЛП(НРег(Формула));
	КолСимволов = СтрДлина(НРегФормула);
	
	// временные переменные
	КэшПеременные = Новый Соответствие;
	
	// разберем формулу на операторы
	МассивОператоров = ПолучитьОператорыПоУбываниюДлины();
	Для Каждого Оператор Из МассивОператоров Цикл
		КлючПоиска = НРег(Оператор.Оператор);
		
		ПроверитьОкончание = СтроковыеФункцииКлиентСервер.ТолькоКириллицаВСтроке(КлючПоиска);
		
		КонПозиция = 1;
		НачПозиция = СтрНайти(НРегФормула, КлючПоиска,, КонПозиция);
		Пока НачПозиция <> 0 Цикл
			Если Оператор.ЕстьОкончание Тогда
				КонПозиция = НайтиОкончаниеОператора(НРегФормула, НачПозиция);
			Иначе 
				КонПозиция = НачПозиция + СтрДлина(КлючПоиска);
			КонецЕсли;
			
			Если ПроверитьОкончание Тогда
				СледСимвол	= Сред(НРегФормула, КонПозиция + 1, 1);
				ЭтоБуква	= СтроковыеФункцииКлиентСервер.ТолькоКириллицаВСтроке(СледСимвол)
					ИЛИ СтроковыеФункцииКлиентСервер.ТолькоЛатиницаВСтроке(СледСимвол);
					
				Если ЭтоБуква Тогда
					НачПозиция = СтрНайти(НРегФормула, КлючПоиска,, КонПозиция);
					Продолжить;
				КонецЕсли;
			КонецЕсли;
			
			Если Оператор.ЕстьОкончание Тогда
				ДанныеОператора = Неопределено;
				
				СтрОператор		= Сред(НРегФормула, НачПозиция, КонПозиция - НачПозиция + 1);
				ВнутрФормула	= Сред(СтрОператор, СтрДлина(КлючПоиска) + 1, СтрДлина(СтрОператор) - СтрДлина(КлючПоиска) - 1);
				Если ЗначениеЗаполнено(ВнутрФормула) Тогда
					ДанныеОператора = РазобратьФормулу(ВнутрФормула);
				КонецЕсли;
					
				ИмяПеременной = СтрШаблон("math_m_%1", Формат(КэшПеременные.Количество() + 1, "ЧГ="));
				КэшПеременные.Вставить(ИмяПеременной, Новый Структура("Формула,Элементы", СтрОператор, ДанныеОператора));
			Иначе 
				ИмяПеременной = СокрЛП(КлючПоиска);
			КонецЕсли;
			
			НРегФормула = СтрШаблон("%1 %2 %3",
				Лев(НРегФормула, НачПозиция - 1),
				ИмяПеременной,
				Сред(НРегФормула, КонПозиция + 1));
				
			НачПозиция = СтрНайти(НРегФормула, КлючПоиска,, КонПозиция + 1);
		КонецЦикла;
	КонецЦикла;
	
	МассивЧастей = СтрРазделить(НРегФормула, " ", Ложь);

	Возврат ДеревоФормулы;
КонецФункции

Функция ОператорЧастьСлова(знач Формула, знач НачПозиции, знач КонПозиции)
	ПредСимвол = Сред(Формула, НачПозиции - 1, 1);
	СледСимвол = Сред(Формула, КонПозиции, 1);
	
	Если НЕ ЗначениеЗаполнено(ПредСимвол) И НЕ ЗначениеЗаполнено(СледСимвол) Тогда
		Возврат Ложь;
	ИначеЕсли СтроковыеФункцииКлиентСервер.ЭтоРазделительСлов(КодСимвола(ПредСимвол))
		И СтроковыеФункцииКлиентСервер.ЭтоРазделительСлов(КодСимвола(СледСимвол)) Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ЭтоОкончание = ЗначениеЗаполнено(ПредСимвол)
		И (СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ПредСимвол)
			ИЛИ СтроковыеФункцииКлиентСерверРФ.ТолькоКириллицаВСтроке(ПредСимвол, Ложь, "_")
			ИЛИ СтроковыеФункцииКлиентСервер.ТолькоЛатиницаВСтроке(ПредСимвол, Ложь));
		
	Если ЭтоОкончание Тогда
		Возврат Истина;
	КонецЕсли;
	
	ЭтоНачало = ЗначениеЗаполнено(СледСимвол)
		И (СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(СледСимвол)
			ИЛИ СтроковыеФункцииКлиентСерверРФ.ТолькоКириллицаВСтроке(СледСимвол, Ложь, "_")
			ИЛИ СтроковыеФункцииКлиентСервер.ТолькоЛатиницаВСтроке(СледСимвол, Ложь));
		
	Если ЭтоНачало Тогда
		Возврат Истина;
	КонецЕсли;
	
	Возврат Ложь;
КонецФункции

Функция ПолучитьОператорыПоУбываниюДлины(знач Арифметические = Истина, знач Логические = Истина, знач Математические = Истина, знач Строковые = Истина) Экспорт
	МассивПоДлине = Новый Массив;
	
	НаборОператоров = Новый Массив;
	Если Арифметические Тогда
		НаборОператоров.Добавить(АрифметическиеОператоры());
	КонецЕсли;
	Если Логические Тогда
		НаборОператоров.Добавить(ЛогическиеОператоры());
	КонецЕсли;
	Если Математические Тогда
		НаборОператоров.Добавить(МатематическиеОператоры());
	КонецЕсли;
	Если Строковые Тогда
		НаборОператоров.Добавить(СтроковыеОператоры());
	КонецЕсли;
	
	// дополнительные операторы
	ДопОператоры = Новый Массив;
	ДобавитьОператор(ДопОператоры, "М", "(",, " (", Истина);
	НаборОператоров.Добавить(ДопОператоры);
	
	Для Каждого Операторы Из НаборОператоров Цикл
		Для Каждого Оператор Из Операторы Цикл
			ДлинаОператора = СтрДлина(Оператор.Оператор);
			Если ДлинаОператора = 0 Тогда
				Продолжить;
			КонецЕсли;
			
			Если ДлинаОператора <= МассивПоДлине.Количество() Тогда
				МассивОператоров = МассивПоДлине[ДлинаОператора-1];
			Иначе 
				МассивПоДлине.Вставить(ДлинаОператора-1, Новый Массив);
			КонецЕсли;
			
			МассивОператоров = МассивПоДлине[ДлинаОператора-1];
			Если НЕ ТипЗнч(МассивОператоров) = Тип("Массив") Тогда
				МассивПоДлине[ДлинаОператора-1] = Новый Массив;
			КонецЕсли;
			
			МассивПоДлине[ДлинаОператора-1].Добавить(Оператор);
		КонецЦикла;
	КонецЦикла;
	
	Результат = Новый Массив;
	
	ГраницаМассива	= МассивПоДлине.ВГраница();
	Для Индекс = 0 По ГраницаМассива Цикл
		МассивОператоров = МассивПоДлине[ГраницаМассива - Индекс];
		Если НЕ ТипЗнч(МассивОператоров) = Тип("Массив") Тогда
			Продолжить;
		КонецЕсли;
		
		Для Каждого Оператор Из МассивОператоров Цикл
			Результат.Добавить(Оператор);
		КонецЦикла;
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

Функция НайтиОкончаниеОператора(знач Формула, знач НачПозиция)
	Счетчик		= 1;
	КолСимволов = СтрДлина(Формула);
	Для Индекс = 1 По КолСимволов Цикл
		ЗначСимвол = Сред(Формула, НачПозиция + Индекс, 1);
		Если ЗначСимвол = "(" Тогда
			Счетчик = Счетчик + 1;
		ИначеЕсли ЗначСимвол = ")" Тогда
			Счетчик = Счетчик - 1;
		КонецЕсли;
		
		Если Счетчик = 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Возврат НачПозиция + Индекс;
КонецФункции

#КонецОбласти 
