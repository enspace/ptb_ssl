
#Область ПрограммныйИнтерфейс_Общий

// Заполняет настройку отбора получателя по данным источника
//
// Параметры:
//	Получатель		- КомпоновщикНастроекКомпоновкиДанных, ОтборКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных
//		КомпоновщикНастроекКомпоновкиДанных - используется коллекция Настройки.Отбор
//	Источник		- КомпоновщикНастроекКомпоновкиДанных, ОтборКомпоновкиДанных, ГруппаЭлементовОтбораКомпоновкиДанных, Структура, ФиксированнаяСтруктура
//		КомпоновщикНастроекКомпоновкиДанных - используется коллекция Настройки.Отбор
//		Структура
//			Ключ - ЛевоеЗначение
//			Значение - ПравоеЗначение. Если в качестве значения передан список, массив или фикс. массив, исп. вид сравнения ВСписке
//	ПроверятьПоля	- Булево - в случае если значение Истина, то в отборы получателя попадают только ДоступныеПоля
//	ПоляЗамены		- Соответствие, ФиксированноеСоответствие, Неопределено
// 
Процедура ЗаполнитьОтборКомпоновкиДанныхПоИсточнику(Получатель, знач Источник, знач ПроверятьПоля = Ложь, знач ПоляЗамены = Неопределено) Экспорт 
	Отказ = Ложь;
	
	ТипПолучатель	= ТипЗнч(Получатель);
	ТипИсточник		= ТипЗнч(Источник);
	
	ОтборПолучатель = Неопределено;
	ОтборИсточник	= Неопределено;
	Если ТипПолучатель = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		ОтборПолучатель = Получатель.Настройки.Отбор;
	ИначеЕсли ТипПолучатель = Тип("ОтборКомпоновкиДанных") ИЛИ ТипПолучатель = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ОтборПолучатель = Получатель;
	КонецЕсли;
		
	Если ТипИсточник = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		ОтборИсточник = Источник.Настройки.Отбор;
	ИначеЕсли ТипИсточник = Тип("ОтборКомпоновкиДанных") ИЛИ ТипИсточник = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
		ОтборИсточник = Источник;
	ИначеЕсли ТипИсточник = Тип("ФиксированнаяСтруктура") Тогда
		ОтборИсточник = Новый Структура(Источник);
	ИначеЕсли ТипИсточник = Тип("Структура") Тогда
		ОтборИсточник = Источник;
	КонецЕсли;
	
	Если ПроверятьПоля И НЕ ТипПолучатель = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		ПроверятьПоля = Ложь;
	КонецЕсли;
	
	Если ОтборПолучатель = Неопределено ИЛИ ОтборИсточник = Неопределено Тогда
		Возврат;
	КонецЕсли;
	
	Если ТипЗнч(ОтборИсточник) = Тип("Структура") Тогда
		ЗаполнитьОтборКомпоновкиДанныхПоСтруктуре(ОтборПолучатель, ОтборИсточник, ПроверятьПоля, ПоляЗамены);
	Иначе 
		РекурсивноЗаполнитьОтборКомпоновкиДанных(ОтборПолучатель, ОтборИсточник, ПроверятьПоля, ПоляЗамены);
	КонецЕсли;
КонецПроцедуры

// Выполняет поиск составных частей поля в массиве замен. Если не найдено возвращает само поле
// В массиве замен (ПоляЗамены) допустимо использовать часть имени. Например:
//		Задолженность.Дт будет использоваться для всех полей Задолженность.Дт.<ИмяПоля>
//
// При необходимости можно задать поле "*" со значением "" (пустая строка), тогда это значение
// будет приниматься для всех полей, не найденных в массиве замен (ПоляЗамены)
//
// Параметры:
//	Поле		- Строка - путь к данным поля компоновки данных
//	ПоляЗамены	- Соответствие - набор путей к данным полей. Допустимо использовать часть имени
//
// Возвращаемое значение:
//   Строка - если в списке не найдено значение, возвращается само значение поля
// 
Функция ПолучитьПолеЗамены(знач Поле, знач ПоляЗамены) Экспорт
	МассивПодстрок	= СтрРазделить(Поле, ".", Ложь);
	
	ОстатокСтроки	= "";
	
	ИндексСтроки	= МассивПодстрок.ВГраница();
	ПолеПроверки	= СтрСоединить(МассивПодстрок, ".");
	ПолеЗамены		= ПоляЗамены.Получить(ПолеПроверки);
	Пока ПолеЗамены = Неопределено Цикл
		ОстатокСтроки = МассивПодстрок[ИндексСтроки] + ?(ПустаяСтрока(ОстатокСтроки), "", ".") + ОстатокСтроки;
		
		МассивПодстрок.Удалить(ИндексСтроки);
		
		ИндексСтроки	= ИндексСтроки - 1;
		ПолеПроверки 	= СтрСоединить(МассивПодстрок, ".");
		ПолеЗамены		= ПоляЗамены.Получить(ПолеПроверки);
		
		Если ИндексСтроки < 0 Тогда
			Прервать;
		КонецЕсли;
	КонецЦикла;
	
	Если ПолеЗамены <> Неопределено Тогда
		Возврат ПолеЗамены + ?(ПустаяСтрока(ОстатокСтроки), "", ".") + ОстатокСтроки;
	ИначеЕсли ПоляЗамены.Получить("*") = "" Тогда
		Возврат "";
	КонецЕсли;
	
	Возврат Поле;
КонецФункции

// Возвращает пустой уникальный идентификатор
//
// Возвращаемое значение:
//   УникальныйИдентификатор
// 
Функция ПустойИдентификатор() Экспорт
	Возврат Новый УникальныйИдентификатор("00000000-0000-0000-0000-000000000000");
КонецФункции

// Возвращает строку для разделения запросов в пакете
//
// Возвращаемое значение:
//   Строка
// 
Функция ТекстРазделителяЗапросовПакета() Экспорт

	ТекстРазделителя =
	"
	|;
	|
	|////////////////////////////////////////////////////////////////////////////////
	|";

	Возврат ТекстРазделителя;

КонецФункции

// Возвращает строковое представление дня недели.
//
// Параметры:
//  НомерДняНедели	- Число - номер для недели.
//	Сокращенное		- Булево - возвращать полное или сокращенное представление
//
// Возвращаемое значение:
//   Строка - Строковое представление дня недели.
//
Функция ПредставлениеДняНедели(знач НомерДняНедели, знач Сокращенное = Ложь) Экспорт

	Результат = СтрШаблон(
		НСтр("ru='Неопределено (%1);??? (%1)'"),
		НомерДняНедели);

	Если НомерДняНедели = 1 Тогда
		Результат = НСтр("ru='Понедельник;Пн'");
	ИначеЕсли НомерДняНедели = 2 Тогда
		Результат = НСтр("ru='Вторник;Вт'");
	ИначеЕсли НомерДняНедели = 3 Тогда
		Результат = НСтр("ru='Среда;Ср'");
	ИначеЕсли НомерДняНедели = 4 Тогда
		Результат = НСтр("ru='Четверг;Чт'");
	ИначеЕсли НомерДняНедели = 5 Тогда
		Результат = НСтр("ru='Пятница;Пт'");
	ИначеЕсли НомерДняНедели = 6 Тогда
		Результат = НСтр("ru='Суббота;Сб'");
	ИначеЕсли НомерДняНедели = 7 Тогда
		Результат = НСтр("ru='Воскресенье;Вс'");
	КонецЕсли;
	
	МассивДниНедели = СтрРазделить(Результат, ";");
	НомерЗначения	= ?(Сокращенное = Истина, 1, 0);

	Возврат МассивДниНедели[НомерЗначения];

КонецФункции

// Возвращает имя для ключа структуры из наименования
//	- удаляются все пробелы
//	- каждый первый символ нового слова переводится в верхний регистр, остальные остаются как есть
//	- все символы кроме чисел, кириллицы, латиницы и "_" не учитываются
//	- если имя начинается с числа, тогда первым символом будет "_". Т.е. имя будет "_1", вместо "1"
//
// Параметры:
//	Наименование - Строка
//
// Возвращаемое значение:
//   Строка
// 
Функция ПолучитьКлючСтруктурыИзНаименования(знач Наименование) Экспорт
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Наименование, " ", Истина, Истина);
	
	ИмяКлюча = "";
	Для Индекс = 0 По МассивПодстрок.ВГраница() Цикл
		Подстрока = МассивПодстрок[Индекс];
		
		НовСтрока = "";
		Для НомерСимвола = 1 По СтрДлина(Подстрока) Цикл
			ЗначСимвол = Сред(Подстрока, НомерСимвола, 1);
			Если НомерСимвола = 1 Тогда
				ЗначСимвол = ВРег(ЗначСимвол);
			КонецЕсли;
			
			Если ЗначСимвол = "_"
				ИЛИ СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ЗначСимвол)
				ИЛИ СтроковыеФункцииКлиентСервер.ТолькоЛатиницаВСтроке(ЗначСимвол)
				ИЛИ СтроковыеФункцииКлиентСерверРФ.ТолькоКириллицаВСтроке(ЗначСимвол) Тогда
				
				НовСтрока = НовСтрока + ЗначСимвол;
				
			КонецЕсли;
		КонецЦикла;
		
		ИмяКлюча = ИмяКлюча + НовСтрока;
	КонецЦикла;
	
	ПервыйСимвол = Лев(ИмяКлюча, 1);
	Если СтроковыеФункцииКлиентСервер.ТолькоЦифрыВСтроке(ПервыйСимвол) Тогда
		ИмяКлюча = "_" + ИмяКлюча;
	КонецЕсли;
	
	Возврат ИмяКлюча;
КонецФункции

// Проверяет наличие реквизита или свойства у произвольного объекта без обращения к метаданным.
// Альтернативная реализация метода ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта
// с возможностью указать полный путь к реквизиту. Например: Объект.Ссылка
//
// Параметры:
//  Объект       	- Произвольный - объект, у которого нужно проверить наличие реквизита или свойства;
//  ПутьКРеквизиту	- Строка - полный путь к реквизиту (допустимо указывать путь Объект.Ссылка)
//
// Возвращаемое значение:
//  Булево - Истина, если есть.
//
Функция ЕстьРеквизитИлиСвойствоОбъекта(знач Объект, знач ПутьКРеквизиту) Экспорт
	РеквизитСуществует = Ложь;

	МассивИмен = СтрРазделить(ПутьКРеквизиту, ".");
	Если МассивИмен.Количество() = 0 Тогда
		Возврат РеквизитСуществует;
	КонецЕсли;

	РеквизитОбъекта = Объект;
	Для Каждого ИмяРеквизита Из МассивИмен Цикл
		ИмяРеквизита		= СокрЛП(ИмяРеквизита);
		РеквизитСуществует	= ОбщегоНазначенияКлиентСервер.ЕстьРеквизитИлиСвойствоОбъекта(РеквизитОбъекта, ИмяРеквизита);

		Если РеквизитСуществует Тогда
			РеквизитОбъекта = РеквизитОбъекта[ИмяРеквизита];
		КонецЕсли;
	КонецЦикла;
	
	Возврат РеквизитСуществует;
КонецФункции

// Возвращает номер картинки из коллекции ПиктограммыТиповДанных по указанному типу
// Ссылки не проверяет, они возвращаются как Неопределено, исп. аналогичный метод ОбщегоНазначенияПТБ
//
// Параметры:
//	ТипЗначения - Тип
//
// Возвращаемое значение:
//   Число
//
Функция НомерКартинкиПоТипуДанных(знач ТипЗначения) Экспорт 
	Если ТипЗначения = Тип("Булево") Тогда
		Возврат 0;
	ИначеЕсли ТипЗначения = Тип("Дата") Тогда
		Возврат 2;
	ИначеЕсли ТипЗначения = Тип("Строка") Тогда
		Возврат 8;
	ИначеЕсли ТипЗначения = Тип("УникальныйИдентификатор") Тогда
		Возврат 4;
	ИначеЕсли ТипЗначения = Тип("Картинка") Тогда
		Возврат 17;
	ИначеЕсли ТипЗначения = Тип("Число") Тогда
		Возврат 13;
	ИначеЕсли ТипЗначения = Тип("Структура") ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура") Тогда
		Возврат 1;
	ИначеЕсли ТипЗначения = Тип("Соответствие") ИЛИ ТипЗначения = Тип("ФиксированноеСоответствие") Тогда
		Возврат 1;
	ИначеЕсли ТипЗначения = Тип("Массив") ИЛИ ТипЗначения = Тип("ФиксированныйМассив") ИЛИ ТипЗначения = Тип("СписокЗначений") Тогда
		Возврат 9;
	КонецЕсли;
	
	Возврат 18;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Данные

// Дополняет массив из переданных данных реквизитов
//
// Параметры:
//	Массив 		- Массив
//	Реквизиты	- Строка, Массив, Соответствие, Структура - в т.ч. фиксированные варианты коллекций
//
Процедура ДополнитьМассивИзЗначения(знач Массив, знач Реквизиты) Экспорт
	ТипРеквизиты = ТипЗнч(Реквизиты);
	Если ТипРеквизиты = Тип("Строка") Тогда
		
		Подстроки = СтрРазделить(Реквизиты, ",");
		Для Каждого ИмяРеквизита Из Подстроки Цикл
			ИмяРеквизита = СокрЛП(ИмяРеквизита);
			Если Массив.Найти(ИмяРеквизита) = Неопределено Тогда
				Массив.Добавить(ИмяРеквизита);
			КонецЕсли;
		КонецЦикла;
		
	ИначеЕсли ТипРеквизиты = Тип("Массив") ИЛИ ТипРеквизиты = Тип("ФиксированныйМассив") Тогда
		
		ОбщегоНазначенияКлиентСервер.ДополнитьМассив(Массив, Реквизиты, Истина);
		
	ИначеЕсли ТипРеквизиты = Тип("Соответствие") ИЛИ ТипРеквизиты = Тип("ФиксированноеСоответствие")
		ИЛИ ТипРеквизиты = Тип("Структура") ИЛИ ТипРеквизиты = Тип("ФиксированнаяСтруктура") Тогда
		
		Для Каждого КлючИЗначение Из Реквизиты Цикл
			ИмяРеквизита = СокрЛП(КлючИЗначение.Ключ);
			Если Массив.Найти(ИмяРеквизита) = Неопределено Тогда
				Массив.Добавить(ИмяРеквизита);
			КонецЕсли;
		КонецЦикла;
		
	КонецЕсли;
КонецПроцедуры

// Дополняет структуру или соответствие значениями из другой структуры, соответствия или фикс. аналогов.
//
// Параметры:
//   Приемник	- Структура, Соответствие - коллекция, в которую будут добавляться новые значения.
//   Источник	- Структура, Соответствие, ФиксированнаяСтруктура, ФиксированноеСоответствие - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Префикс	- Строка - префикс перед новым ключом
//   Ключи		- Строка - список ключей для заполнения
//   Исключения	- Строка - список ключей для исключения
//
Процедура ДополнитьКоллекцию(знач Приемник, знач Источник, знач Префикс = "", знач Ключи = "", знач Исключения = "") Экспорт
	ТипПриемник = ТипЗнч(Приемник);
	ТипИсточник = ТипЗнч(Источник);
	
	Если НЕ ТипПриемник = Тип("Структура") И НЕ ТипПриемник = Тип("Соответствие") Тогда
		Возврат;
	ИначеЕсли НЕ ЭтоСтруктура(Источник) И НЕ ЭтоСоответствие(Источник) Тогда 
		Возврат;
	КонецЕсли;
	
	СписокКлючей		= СтрРазделить(СтрЗаменить(Ключи, " ", ""), ",", Ложь);
	СписокИсключений	= СтрРазделить(СтрЗаменить(Исключения, " ", ""), ",", Ложь);
	
	ФильтрНаличие		= СписокКлючей.Количество() > 0;
	ФильтрИсключение	= СписокИсключений.Количество() > 0;
	Для Каждого Элемент Из Источник Цикл
		Если ФильтрНаличие И СписокКлючей.Найти(Элемент.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ФильтрИсключение И НЕ СписокИсключений.Найти(Элемент.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Приемник.Вставить(Префикс + Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
КонецПроцедуры

// Дополняет структуру значениями из другой структуры.
//
// Параметры:
//   Приемник	- Структура - коллекция, в которую будут добавляться новые значения.
//   Источник	- Структура - коллекция, из которой будут считываться пары Ключ и Значение для заполнения.
//   Префикс	- Строка - префикс перед новым ключом
//   Ключи		- Строка - список ключей для заполнения
//   Исключения	- Строка - список ключей для исключения
//
Процедура ДополнитьСтруктуру(знач Приемник, знач Источник, знач Префикс = "", знач Ключи = "", знач Исключения = "") Экспорт
	Если НЕ ТипЗнч(Приемник) = Тип("Структура") Тогда
		Возврат;
	ИначеЕсли НЕ ЭтоСтруктура(Источник) Тогда 
		Возврат;
	КонецЕсли;
	
	СписокКлючей		= СтрРазделить(СтрЗаменить(Ключи, " ", ""), ",", Ложь);
	СписокИсключений	= СтрРазделить(СтрЗаменить(Исключения, " ", ""), ",", Ложь);
	
	ФильтрНаличие		= СписокКлючей.Количество() > 0;
	ФильтрИсключение	= СписокИсключений.Количество() > 0;
	Для Каждого Элемент Из Источник Цикл
		Если ФильтрНаличие И СписокКлючей.Найти(Элемент.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Если ФильтрИсключение И НЕ СписокИсключений.Найти(Элемент.Ключ) = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		Приемник.Вставить(Префикс + Элемент.Ключ, Элемент.Значение);
	КонецЦикла;
КонецПроцедуры

// Устанавливает свойство в структуре по полному пути. Актуально для установки значения
// по длинной цепочки вложенных структур.
//
// Параметры:
//	Структура 		- Структура
//	ПутьКСвойству 	- Строка - в качестве разделителя используется символ "."
//	Значение		- Произвольный - значение для установки
//
Процедура УстановитьСвойствоСтруктуры(знач Структура, знач ПутьКСвойству, знач Значение) Экспорт
	Перем ЗначениеСтруктуры;
		
	МассивИмен = СтрРазделить(ПутьКСвойству, ".", Ложь);
	Для Индекс = 0 По МассивИмен.ВГраница() Цикл
		ИмяСвойства = СокрЛП(МассивИмен[Индекс]);
		Источник	= ?(Индекс = 0, Структура, ЗначениеСтруктуры);
		
		Если НЕ ТипЗнч(Источник) = Тип("Структура") Тогда
			ТекстОшибки = СтрШаблон(НСтр("ru='Ошибка установки свойства ""%1"" (%2)'"),
				ИмяСвойства,
				ПутьКСвойству);
			ВызватьИсключение ТекстОшибки;
		КонецЕсли;
		
		Если Индекс <> МассивИмен.ВГраница() Тогда
			Если НЕ Источник.Свойство(ИмяСвойства) Тогда
				Источник.Вставить(ИмяСвойства, Новый Структура);
			КонецЕсли;
			ЗначениеСтруктуры = Источник[ИмяСвойства];
		Иначе 
			Источник.Вставить(ИмяСвойства, Значение);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Вычисляет значение из соответствия по полному пути. Актуально для получения значения
// по длинной цепочки вложенных соответствий (например из результата чтения JSON в соответствие). 
// Допускается наличие фиксированных соответствий
//
// Например: если соответствие имеет структуру Ключ - строка, Значение - соответствие/значение
// Необходимо получить значение свойства Ключ1 > Ключ2 > Ключ3, предполагая что значением каждого
// ключа (кроме последнего) будет Соответствие. При этом если на любом этапе будет получено значение
// не типа "Соответствие" функция вернет значение параметра ПоУмолчанию. Аналогично, если на
// последнем ключе будет получено значение Неопределено
//
// Параметры:
//	Соответствие 	- Соответствие
//		Ключ - Строка - 
//		Значение - Соответствие, Произвольный
//	ПутьКСвойству 	- Строка - в качестве разделителя используется символ "/"
//	ПоУмолчанию		- Произвольный - значение возвращаемое по умолчанию, если целевое значение не получено
//
// Возвращаемое значение:
//   Произвольный
// 
Функция СвойствоСоответствия(знач Соответствие, знач ПутьКСвойству, знач ПоУмолчанию = Неопределено, знач КакЧисло = Ложь) Экспорт
	Перем ЗначениеСоответствия;
	
	ДопустимыеТипы = Новый Массив;
	ДопустимыеТипы.Добавить(Тип("Соответствие"));
	ДопустимыеТипы.Добавить(Тип("ФиксированноеСоответствие"));
	
	Если ДопустимыеТипы.Найти(ТипЗнч(Соответствие)) = Неопределено Тогда
		Возврат ПоУмолчанию;
	КонецЕсли;
	
	МассивИмен = СтрРазделить(ПутьКСвойству, "/", Ложь);
	Для Индекс = 0 По МассивИмен.ВГраница() Цикл
		ИмяСвойства = СокрЛП(МассивИмен[Индекс]);
        Источник	= ?(Индекс = 0, Соответствие, ЗначениеСоответствия);
		
		ЗначениеСоответствия = Источник.Получить(ИмяСвойства);
		Если ЗначениеСоответствия = Неопределено Тогда
			Возврат ПоУмолчанию;
		КонецЕсли;
		
		Если Индекс <> МассивИмен.ВГраница() Тогда
			ЗначениеСоответствия = ?(ДопустимыеТипы.Найти(ТипЗнч(ЗначениеСоответствия)) = Неопределено,
				Новый Соответствие,
				ЗначениеСоответствия);
		КонецЕсли;
	КонецЦикла;
	
	Если КакЧисло = Истина Тогда
		ЗначениеТип = ТипЗнч(ЗначениеСоответствия);
		Если ЗначениеТип = Тип("Число") Тогда
			Возврат ЗначениеСоответствия;
		ИначеЕсли ЗначениеТип = Тип("Строка") Тогда
			Возврат СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеСоответствия);
		Иначе 
			Возврат 0;
		КонецЕсли;
	Иначе 
		Возврат ЗначениеСоответствия;
	КонецЕсли;
КонецФункции

// Вычисляет значение из структуры по полному пути. Актуально для получения значения
// по длинной цепочки вложенных структур. 
// Допускается наличие фиксированных структур
//
// Например: если структура имеет структуру Ключ - строка, Значение - структура/значение
// Необходимо получить значение свойства Ключ1 > Ключ2 > Ключ3, предполагая что значением каждого
// ключа (кроме последнего) будет Структура. При этом если на любом этапе будет получено значение
// не типа "Структура" функция вернет значение параметра ПоУмолчанию. Аналогично, если на
// последнем ключе будет получено значение Неопределено
//
// Параметры:
//	Структура 	- Структура
//		Ключ - Строка - 
//		Значение - Структура, Произвольный
//	ПутьКСвойству 	- Строка - в качестве разделителя используется символ "."
//	ПоУмолчанию		- Произвольный - значение возвращаемое по умолчанию, если целевое значение не получено
//
// Возвращаемое значение:
//   Произвольный
// 
Функция СвойствоСтруктуры(знач Структура, знач ПутьКСвойству, знач ПоУмолчанию = Неопределено, знач КакЧисло = Ложь) Экспорт
	Перем ЗначениеСтруктуры;
	
	ДопустимыеТипы = Новый Массив;
	ДопустимыеТипы.Добавить(Тип("Структура"));
	ДопустимыеТипы.Добавить(Тип("ФиксированнаяСтруктура"));
	
	Если ДопустимыеТипы.Найти(ТипЗнч(Структура)) = Неопределено Тогда
		Возврат ПоУмолчанию;
	КонецЕсли;
	
	МассивИмен = СтрРазделить(ПутьКСвойству, ".", Ложь);
	Для Индекс = 0 По МассивИмен.ВГраница() Цикл
		ИмяСвойства = СокрЛП(МассивИмен[Индекс]);
        Источник	= ?(Индекс = 0, Структура, ЗначениеСтруктуры);
		
		Если НЕ Источник.Свойство(ИмяСвойства, ЗначениеСтруктуры) Тогда
			Возврат ПоУмолчанию;
		КонецЕсли;
		
		Если Индекс <> МассивИмен.ВГраница() Тогда
			ЗначениеСтруктуры = ?(ДопустимыеТипы.Найти(ТипЗнч(ЗначениеСтруктуры)) = Неопределено,
				Новый Структура,
				ЗначениеСтруктуры);
		КонецЕсли;
	КонецЦикла;
	
	Если КакЧисло = Истина Тогда
		ЗначениеТип = ТипЗнч(ЗначениеСтруктуры);
		Если ЗначениеТип = Тип("Число") Тогда
			Возврат ЗначениеСтруктуры;
		ИначеЕсли ЗначениеТип = Тип("Строка") Тогда
			Возврат СтроковыеФункцииКлиентСервер.СтрокаВЧисло(ЗначениеСтруктуры);
		Иначе 
			Возврат 0;
		КонецЕсли;
	Иначе 
		Возврат ЗначениеСтруктуры;
	КонецЕсли;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Таблица

// Выполняет удаление строк из табличной части по переданному массиву
//
// Параметры:
//	ТабличнаяЧасть	- ДанныеФормыКоллекция, ТаблицаЗначений, ТабличнаяЧасть
//	МассивСтрок		- Массив - элементы коллекции для удаления
//
Процедура УдалитьСтрокиТабличнойЧасти(знач Коллекция, знач МассивСтрок) Экспорт
	Для Каждого СтрокаТаблицы Из МассивСтрок Цикл
		ИндексСтроки = Коллекция.Индекс(СтрокаТаблицы);
		Если ИндексСтроки >= 0 Тогда
			Коллекция.Удалить(ИндексСтроки);
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

// Возвращает массив строк по переданным идентификаторам табличной части
// Если значение пустое, возвращается сама табличная часть
//
// Параметры:
//	ТабЧасть			- ДанныеФормыКоллекция, ДанныеФормыДерево
//	ОтборИдентификатор	- Число, Массив, Неопределено - для прочих типов возвращается пустой массив
//		Число - поиск по идентификатору
//		Массив - поиск по массиву идентификаторов
//		Неопределено - возвращается вся табличная часть
//
// Возвращаемое значение:
//   ТабЧасть, Массив
// 
Функция СтрокиТаблицыПоИдентификатору(знач ТабЧасть, знач ОтборИдентификатор) Экспорт
	МассивСтрок = Новый Массив;
	
	Если ТипЗнч(ОтборИдентификатор) = Тип("Число") Тогда
		СтрокаТЧ = ТабЧасть.НайтиПоИдентификатору(ОтборИдентификатор);
		Если СтрокаТЧ <> Неопределено Тогда
			МассивСтрок.Добавить(СтрокаТЧ);
		КонецЕсли;
	ИначеЕсли ТипЗнч(ОтборИдентификатор) = Тип("Массив") Тогда
		Для Каждого ИдентификаторСтроки Из ОтборИдентификатор Цикл
			СтрокаТЧ = ТабЧасть.НайтиПоИдентификатору(ИдентификаторСтроки);
			Если СтрокаТЧ <> Неопределено Тогда
				МассивСтрок.Добавить(СтрокаТЧ);
			КонецЕсли;
		КонецЦикла;
	Иначе 
		Возврат ТабЧасть;
	КонецЕсли;
	
	Возврат МассивСтрок;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_СКД

// Добавляет в группировку автоэлемент порядка
Процедура ДобавитьАвтоЭлементПорядка(Строка) Экспорт
	ПолеПолеПорядок = Строка.Порядок.Элементы.Добавить(Тип("АвтоЭлементПорядкаКомпоновкиДанных"));
КонецПроцедуры

// Получает параметр вывода компоновщика настроек или настройки СКД
//
// Параметры:
//		КомпоновщикНастроекГруппировка - компоновщик настроек или настройка/группировка СКД
//		ИмяПараметра - имя параметра СКД
//
Функция ПолучитьПараметрВывода(Настройка, ИмяПараметра) Экспорт
	МассивПараметров   = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ИмяПараметра, ".");
	УровеньВложенности = МассивПараметров.Количество();
	
	Если УровеньВложенности > 1 Тогда
		ИмяПараметра = МассивПараметров[0];		
	КонецЕсли;
	
	Если ТипЗнч(Настройка) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		ЗначениеПараметра = Настройка.Настройки.ПараметрыВывода.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	Иначе
		ЗначениеПараметра = Настройка.ПараметрыВывода.НайтиЗначениеПараметра(Новый ПараметрКомпоновкиДанных(ИмяПараметра));
	КонецЕсли;
	
	Если УровеньВложенности > 1 Тогда
		Для Индекс = 1 По УровеньВложенности - 1 Цикл
			ИмяПараметра = ИмяПараметра + "." + МассивПараметров[Индекс];
			ЗначениеПараметра = ЗначениеПараметра.ЗначенияВложенныхПараметров.Найти(ИмяПараметра); 
		КонецЦикла;
	КонецЕсли;
	
	Возврат ЗначениеПараметра;  
КонецФункции

// Возвращает элемент структуры настроек компоновки данных содержащий поле группировки с указанным именем
// Поиск осуществляется по указанной структуре и все ее подчиненным структурам,
// В случае неудачи возвращает Неопределено
//
// Параметры:
// - Структура 	- ГруппировкаТаблицыКомпоновкиДанных, ГруппировкаКомпоновкиДанных, КоллекцияЭлементовСтруктурыТаблицыКомпоновкиДанных 
// 					Элемент структуры компоновки данных,
// - ИмяПоля 	- Строка - Имя поля группировки
//
// Возвращаемое значение:
//	ГруппировкаТаблицыКомпоновкиДанных, ГруппировкаКомпоновкиДанных, Неопределено
//
Функция НайтиГруппировку(Структура, ИмяПоля) Экспорт
	Для Каждого Элемент Из Структура Цикл
		Для Каждого Поле Из Элемент.ПоляГруппировки.Элементы Цикл
			Если ТипЗнч(Поле) = Тип("АвтоПолеГруппировкиКомпоновкиДанных") Тогда
				Продолжить;
			КонецЕсли;
			
			Если Поле.Поле = Новый ПолеКомпоновкиДанных(ИмяПоля) Тогда
				Возврат Элемент;
			КонецЕсли;
		КонецЦикла;
		
		Если Элемент.Структура.Количество() = 0 Тогда
			Возврат Неопределено;
		Иначе
			Группировка = НайтиГруппировку(Элемент.Структура, ИмяПоля);
		КонецЕсли;
	КонецЦикла;
	
	Возврат Группировка;
КонецФункции

// Устанавливает параметр вывода компоновщика настроек или настройки СКД
//
// Параметры:
//	КомпоновщикНастроекГруппировка	- компоновщик настроек или настройка/группировка СКД
//	ИмяПараметра					- Строка - имя параметра СКД
//	Значение						- Произвольный - значение параметра вывода СКД
//	Использование					- Булево- Признак использования параметра. По умолчанию всегда принимается равным истине.
//
Функция УстановитьПараметрВывода(Настройка, ИмяПараметра, Значение, Использование = Истина) Экспорт
	ЗначениеПараметра = ПолучитьПараметрВывода(Настройка, ИмяПараметра);
	
	Если ЗначениеПараметра <> Неопределено Тогда
		ЗначениеПараметра.Использование = Использование;
		ЗначениеПараметра.Значение      = Значение;
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
КонецФункции

// Добавляет отбор в коллекцию отборов компоновщика или группы отборов
//
// Параметры:
//		ЭлементСтруктуры - элемент структуры
//		Поле             - имя поля, по которому добавляется отбор
//		Значение         - значение отбора
//		ВидСравнения     - вид сравнений компоновки данных (по умолчанию: вид сравнения)
//		Использование    - признак использования отбора (по умолчанию: истина)
//
Функция ДобавитьОтбор(ЭлементСтруктуры, Знач Поле, Значение = Неопределено, ВидСравнения = Неопределено, Использование = Истина, ВПользовательскиеНастройки = Ложь) Экспорт
	Если ТипЗнч(Поле) = Тип("Строка") Тогда
		Поле = Новый ПолеКомпоновкиДанных(Поле);
	КонецЕсли;
	
	Если ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Настройки.Отбор;
		
		Если ВПользовательскиеНастройки Тогда
			Для Каждого ЭлементНастройки Из ЭлементСтруктуры.ПользовательскиеНастройки.Элементы Цикл	
				Если ЭлементНастройки.ИдентификаторПользовательскойНастройки = ЭлементСтруктуры.Настройки.Отбор.ИдентификаторПользовательскойНастройки Тогда
					Отбор = ЭлементНастройки;
				КонецЕсли;
			КонецЦикла;
		КонецЕсли;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		Отбор = ЭлементСтруктуры.Отбор;
	Иначе
		Отбор = ЭлементСтруктуры;
	КонецЕсли;
		
	Если ВидСравнения = Неопределено Тогда
		ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
	КонецЕсли;
	
	НовыйЭлемент = Отбор.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
	НовыйЭлемент.Использование  = Использование;
	НовыйЭлемент.ЛевоеЗначение  = Поле;
	НовыйЭлемент.ВидСравнения   = ВидСравнения;
	НовыйЭлемент.ПравоеЗначение = Значение;
	
	Возврат НовыйЭлемент;
	
КонецФункции

// Функция добавляет выбранное поле и возвращает элемент выбранного поля. 
//
// Параметры:
//		ЭлементСтруктуры - компоновщик настроек, настройка СКД, элемент структуры настройки отчета
//		Поле - имя поля, которое нужно добавить в СКД
//		Заголовок - заголовок добавляемого поля
//
Функция ДобавитьВыбранноеПоле(ЭлементСтруктуры, Знач Поле, Заголовок = Неопределено) Экспорт
	Если ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		ВыбранныеПоля = ЭлементСтруктуры.Настройки.Выбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		ВыбранныеПоля = ЭлементСтруктуры.Выбор;
	Иначе
		ВыбранныеПоля = ЭлементСтруктуры;
	КонецЕсли;
	
	Если ТипЗнч(Поле) = Тип("Строка") Тогда
		Поле = Новый ПолеКомпоновкиДанных(Поле);
	КонецЕсли;
	ВыбранноеПоле = ВыбранныеПоля.Элементы.Добавить(Тип("ВыбранноеПолеКомпоновкиДанных"));
	ВыбранноеПоле.Поле = Поле;
	Если Заголовок <> Неопределено Тогда
		ВыбранноеПоле.Заголовок = Заголовок;
	КонецЕсли;
	
	Возврат ВыбранноеПоле;
КонецФункции

// Добавляет в группировку автовыбранное поле
Функция ДобавитьАвтоВыбранноеПоле(ЭлементСтруктуры) Экспорт
	Если ТипЗнч(ЭлементСтруктуры) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		ВыбранныеПоля = ЭлементСтруктуры.Настройки.Выбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("НастройкиКомпоновкиДанных") Тогда
		ВыбранныеПоля = ЭлементСтруктуры.Выбор;
	ИначеЕсли ТипЗнч(ЭлементСтруктуры) = Тип("ГруппировкаТаблицыКомпоновкиДанных") Тогда
		ВыбранныеПоля = ЭлементСтруктуры.Выбор;
	Иначе
		ВыбранныеПоля = ЭлементСтруктуры;
	КонецЕсли;
	
	ВыбранноеПоле = ВыбранныеПоля.Элементы.Добавить(Тип("АвтоВыбранноеПолеКомпоновкиДанных"));
	
	Возврат ВыбранноеПоле;
КонецФункции

// Функция возвращает значение параметра компоновки данных
//
// Параметры:
//  Настройки - Пользовательские настройки СКД, Настройки СКД, Компоновщик настроек
// 				не поддерживает тип ДанныеРасшифровкиКомпоновкиДанных
//  Параметр - имя параметра СКД для которого нужно вернуть значение параметра
//
Функция ПолучитьПараметр(Настройки, Параметр) Экспорт
	ЗначениеПараметра = Неопределено;
	ПолеПараметр = ?(ТипЗнч(Параметр) = Тип("Строка"), Новый ПараметрКомпоновкиДанных(Параметр), Параметр);
	
	Если ТипЗнч(Настройки) = Тип("НастройкиКомпоновкиДанных") Тогда
		ЗначениеПараметра = Настройки.ПараметрыДанных.НайтиЗначениеПараметра(ПолеПараметр);
	ИначеЕсли ТипЗнч(Настройки) = Тип("ПользовательскиеНастройкиКомпоновкиДанных") Тогда
		Для Каждого ЭлементНастройки Из Настройки.Элементы Цикл
			Если ТипЗнч(ЭлементНастройки) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") И ЭлементНастройки.Параметр = ПолеПараметр Тогда
				ЗначениеПараметра = ЭлементНастройки;
				Прервать;
			КонецЕсли;
		КонецЦикла;
	ИначеЕсли ТипЗнч(Настройки) = Тип("КомпоновщикНастроекКомпоновкиДанных") Тогда
		Для Каждого ЭлементНастройки Из Настройки.ПользовательскиеНастройки.Элементы Цикл
			Если ТипЗнч(ЭлементНастройки) = Тип("ЗначениеПараметраНастроекКомпоновкиДанных") И ЭлементНастройки.Параметр = ПолеПараметр Тогда
				ЗначениеПараметра = ЭлементНастройки;
				Прервать;
			КонецЕсли;
		КонецЦикла;
		Если ЗначениеПараметра = Неопределено Тогда
			ЗначениеПараметра = Настройки.Настройки.ПараметрыДанных.НайтиЗначениеПараметра(ПолеПараметр);
		КонецЕсли;
	ИначеЕсли ТипЗнч(Настройки) = Тип("КоллекцияЗначенийПараметровКомпоновкиДанных") Тогда
		ЗначениеПараметра = Настройки.Найти(ПолеПараметр);
	ИначеЕсли ТипЗнч(Настройки) = Тип("ОформлениеКомпоновкиДанных") Тогда
		ЗначениеПараметра = Настройки.НайтиЗначениеПараметра(ПолеПараметр);
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
КонецФункции

// Функция устанавливает значение параметра компоновки данных
//
// Параметры:
//		Настройки     - Пользовательские настройки СКД, Настройки СКД, Компоновщик настроек
//		Параметр      - имя параметра СКД для которого нужно вернуть значение параметра
//      Значение      - значение параметра
//		Использование - Признак использования параметра. По умолчанию всегда принимается равным истине.
//
Функция УстановитьПараметр(Настройки, Параметр, Значение, Использование = Истина) Экспорт
	ЗначениеПараметра = ПолучитьПараметр(Настройки, Параметр);
	
	Если ЗначениеПараметра <> Неопределено Тогда
		ЗначениеПараметра.Использование = Использование;
		ЗначениеПараметра.Значение      = Значение;
	КонецЕсли;
	
	Возврат ЗначениеПараметра;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_ВремяВСекунды

// Возвращает число секунд в месяце
//
// Параметры:
//	ЧислоДней - Число - по умолчанию 30
//
// Возвращаемое значение:
//   Число
// 
Функция МесяцВСекундах(знач ЧислоДней = 30) Экспорт
	Возврат ЧислоДней * ДеньВСекундах();
КонецФункции

// Возвращает число секунд в неделе
//
// Возвращаемое значение:
//   Число
// 
Функция НеделяВСекундах() Экспорт
	Возврат 7 * ДеньВСекундах();
КонецФункции

// Возвращает число секунд в дне
//
// Возвращаемое значение:
//   Число
// 
Функция ДеньВСекундах() Экспорт
	Возврат 24 * ЧасВСекундах();
КонецФункции

// Возвращает число секунд в часе
//
// Возвращаемое значение:
//   Число
// 
Функция ЧасВСекундах() Экспорт 
	Возврат 3600;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_КонвертацияЦветовHEX

// Возвращает представление цвета в виде #ZZZZZZ
//
// Параметры:
//	Красный	- Число
//	Зеленый	- Число
//	Синий	- Число
//
// Возвращаемое значение:
//   ТипВид - описание возвращаемого значения
// 
Функция ЦветВHex(знач Красный, знач Зеленый, знач Синий) Экспорт
	_12 = DecToHex(Красный);
	_34 = DecToHex(Зеленый);
	_56 = DecToHex(Синий);
	
	Возврат "#" + Лев(_12 + "00", 2) + Лев(_34 + "00", 2) + Лев(_56 + "00", 2);
КонецФункции

// Возвращает тип цвет из представления в виде #ZZZZZZ
//
// Параметры:
//	Значение - Строка - hex значение цвета #ZZZZZZ
//
// Возвращаемое значение:
//   Цвет
// 
Функция HexВЦвет(знач Значение) Экспорт
	ЗначениеHex		= Сред(Значение, 2);
	Красный	= HexToDec(Сред(ЗначениеHex, 0 , 2));
	Зеленый	= HexToDec(Сред(ЗначениеHex, 3 , 2));
	Синий	= HexToDec(Сред(ЗначениеHex, 5 , 2));
	
	Возврат Новый Цвет(Красный, Зеленый, Синий);
КонецФункции

#КонецОбласти 

#Область ПрограммныйИнтерфейс_РаботаСЧислами

// Возвращает значение числа по модулю
//
// Параметры:
//	ЗначЧисло - Число
//
// Возвращаемое значение:
//   Число
// 
Функция ЧислоПоМодулю(знач Значение) Экспорт 
	Возврат Макс(Значение, -Значение);
КонецФункции

// Преобразование значения числа из десятеричной в любую другую систему счисления
//
// Параметры:
//	Значение	- Число
//	Нотация		- Число
//
// Возвращаемое значение:
//   Строка
// 
Функция Из_10_В_Любой(знач Значение, знач Нотация) Экспорт
	Если Нотация <= 0 Тогда
		Возврат "";
	КонецЕсли;
	
	Значение = Число(Значение);
	
	Если Значение <= 0 Тогда
		Возврат "0";
	КонецЕсли;
	
	Значение = Цел(Значение);
	Результат = "";
	
	Пока Значение > 0 Цикл
		Результат	= Сред("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", Значение % Нотация + 1, 1) + Результат;
		Значение	= Цел(Значение/Нотация);
	КонецЦикла;
	
	Возврат Результат;
КонецФункции

// Преобразование значения числа из любой другую системы счисления в десятеричную
//
// Параметры:
//	Значение	- Строка
//	Нотация		- Число
//
// Возвращаемое значение:
//   Число
// 
Функция Из_Любой_В_10(знач Значение, знач Нотация) Экспорт
	Если Нотация <= 0  Тогда
		Возврат 0;
	КонецЕсли;
	
	Значение = Врег(СокрЛП(Значение));
	
	Если Значение = "0" Тогда
		Возврат 0;
	КонецЕсли;
	
	Результат	= 0;
	Длина		= СтрДлина(Значение);
	Для Х = 1 По Длина Цикл
		М = 1;
		
		Для У = 1 По Длина - Х Цикл
			М = М * Нотация
		КонецЦикла;
		
		Результат = Результат + (Найти("0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ", Сред(Значение,Х,1)) - 1) * М;
	КонецЦикла;
	
	Возврат Окр(Результат);
КонецФункции

// Преобразование значения числа в HEX
//
// Параметры:
//	Значение - Число
//
// Возвращаемое значение:
//   Строка
// 
Функция DecToHex(знач Значение) Экспорт
	Возврат Из_10_В_Любой(Значение, 16); 
КонецФункции

// Преобразование значения числа из HEX
//
// Параметры:
//	Значение - Строка
//
// Возвращаемое значение:
//   Число
// 
Функция HexToDec(знач Значение) Экспорт
	Возврат Из_Любой_В_10(Значение, 16);
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

Функция ЭтоСоответствие(знач Значение) Экспорт
	ТипЗначения = ТипЗнч(Значение);
	Возврат ТипЗначения = Тип("Соответствие") ИЛИ ТипЗначения = Тип("ФиксированноеСоответствие");
КонецФункции

Функция ЭтоСтруктура(знач Значение) Экспорт
	ТипЗначения = ТипЗнч(Значение);
	Возврат ТипЗначения = Тип("Структура") ИЛИ ТипЗначения = Тип("ФиксированнаяСтруктура");
КонецФункции

Функция ЭтоМассив(знач Значение) Экспорт
	ТипЗначения = ТипЗнч(Значение);
	Возврат ТипЗначения = Тип("Массив") ИЛИ ТипЗначения = Тип("ФиксированныйМассив");
КонецФункции
 
// Обертка над методами СкопироватьРекурсивно из общих модулей, с целью не обращать внимание на Клиент или Сервер
// все параметры и возвращаемое значение см. ОбщегоНазначения.СкопироватьРекурсивно
// 
Функция СкопироватьРекурсивно(Источник, ФиксироватьДанные = Неопределено) Экспорт
	#Если Сервер Тогда
		КопияПараметры = ОбщегоНазначения.СкопироватьРекурсивно(Источник, ФиксироватьДанные);
	#Иначе
		КопияПараметры = ОбщегоНазначенияКлиент.СкопироватьРекурсивно(Источник, ФиксироватьДанные);
	#КонецЕсли
	
	Возврат КопияПараметры;
	
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура РекурсивноЗаполнитьОтборКомпоновкиДанных(Получатель, знач Источник, знач ПроверятьПоля, знач ПоляЗамены, знач ДоступныеПоля = Неопределено)
	Если ПроверятьПоля = Истина И ДоступныеПоля = Неопределено Тогда
		ДоступныеПоля = Получатель.ДоступныеПоляОтбора;
	КонецЕсли;
	
	Для Каждого ЭлементИсточник Из Источник.Элементы Цикл
		Если ТипЗнч(ЭлементИсточник) = Тип("ГруппаЭлементовОтбораКомпоновкиДанных") Тогда
			ЭлементПолучатель = Получатель.Элементы.Добавить(Тип("ГруппаЭлементовОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(ЭлементПолучатель, ЭлементИсточник);
			
			РекурсивноЗаполнитьОтборКомпоновкиДанных(ЭлементПолучатель, ЭлементИсточник, ПроверятьПоля, ПоляЗамены, ДоступныеПоля);
		ИначеЕсли ТипЗнч(ЭлементИсточник) = Тип("ЭлементОтбораКомпоновкиДанных") Тогда
			ЛевоеЗначение = ПолучитьЛевоеЗначениеОтбора(ЭлементИсточник.ЛевоеЗначение, ДоступныеПоля, ПроверятьПоля, ПоляЗамены);
			Если ЛевоеЗначение = Неопределено Тогда
				Продолжить;
			КонецЕсли;
			
			ЭлементПолучатель = Получатель.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
			ЗаполнитьЗначенияСвойств(ЭлементПолучатель, ЭлементИсточник,, "ЛевоеЗначение");
			
			ЭлементПолучатель.ЛевоеЗначение = ЛевоеЗначение;
		КонецЕсли;
	КонецЦикла;
КонецПроцедуры

Процедура ЗаполнитьОтборКомпоновкиДанныхПоСтруктуре(Получатель, знач Источник, знач ПроверятьПоля, знач ПоляЗамены)
	Перем ВидСравнения;
	
	Для Каждого КлючИЗначение Из Источник Цикл
		ЛевоеЗначение	= КлючИЗначение.Ключ;
		ПравоеЗначение	= КлючИЗначение.Значение;
		
		Если ТипЗнч(ПравоеЗначение) = Тип("Массив")
			ИЛИ ТипЗнч(ПравоеЗначение) = Тип("ФиксированныйМассив")
			ИЛИ ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений") Тогда
			
			Если ПравоеЗначение.Количество() = 1 Тогда
				ВидСравнения	= ВидСравненияКомпоновкиДанных.Равно;
				ПравоеЗначение	= ?(ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений"),
					ПравоеЗначение[0].Значение,
					ПравоеЗначение[0]);
			Иначе 
				ВидСравнения = ВидСравненияКомпоновкиДанных.ВСписке;
				
				Если НЕ ТипЗнч(ПравоеЗначение) = Тип("СписокЗначений") Тогда
					Если ТипЗнч(ПравоеЗначение) = Тип("ФиксированныйМассив") Тогда
						ПравоеЗначение = Новый Массив(ПравоеЗначение);
					КонецЕсли;
					
					Список = Новый СписокЗначений;
					Список.ЗагрузитьЗначения(ПравоеЗначение);
					
					ПравоеЗначение = Список;
				КонецЕсли;
			КонецЕсли;
		Иначе
			ВидСравнения = ВидСравненияКомпоновкиДанных.Равно;
		КонецЕсли;

		ЛевоеЗначение = ПолучитьЛевоеЗначениеОтбора(ЛевоеЗначение, Получатель.ДоступныеПоляОтбора, ПроверятьПоля, ПоляЗамены);
		Если ЛевоеЗначение = Неопределено Тогда
			Продолжить;
		КонецЕсли;
		
		ЭлементПолучатель = Получатель.Элементы.Добавить(Тип("ЭлементОтбораКомпоновкиДанных"));
		ЭлементПолучатель.ЛевоеЗначение 	= ЛевоеЗначение;
		ЭлементПолучатель.ВидСравнения		= ВидСравнения;
		ЭлементПолучатель.ПравоеЗначение	= ПравоеЗначение;
		ЭлементПолучатель.Использование		= Истина;
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьЛевоеЗначениеОтбора(знач ЛевоеЗначение, знач ДоступныеПоля, знач ПроверятьПоле, знач ПоляЗамены)
	Если НЕ ПоляЗамены = Неопределено Тогда
		СтрЛевоеЗначение = ПолучитьПолеЗамены(Строка(ЛевоеЗначение), ПоляЗамены);
		ЛевоеЗначение = Новый ПолеКомпоновкиДанных(СтрЛевоеЗначение);
	КонецЕсли;
		
	Если ПроверятьПоле = Истина Тогда
		ПолеДоступно = ПолеОтбораСодержитсяВДоступныхПолях(ЛевоеЗначение, ДоступныеПоля);
		Если НЕ ПолеДоступно Тогда
			Возврат Неопределено;
		КонецЕсли;
	КонецЕсли;
	
	Возврат ?(ТипЗнч(ЛевоеЗначение) = Тип("Строка"), Новый ПолеКомпоновкиДанных(ЛевоеЗначение), ЛевоеЗначение);
КонецФункции

Функция ПолеОтбораСодержитсяВДоступныхПолях(Знач ЛевоеЗначение, Знач ДоступныеПоля)
	МассивПолей = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(Строка(ЛевоеЗначение), ".", Истина, Истина);
	Если МассивПолей.Количество() = 0 Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДоступноеПоле = ДоступныеПоля.НайтиПоле(Новый ПолеКомпоновкиДанных(МассивПолей[0]));
	Возврат ТипЗнч(ДоступноеПоле) = Тип("ДоступноеПолеОтбораКомпоновкиДанных");
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Устарело

// Устарела. Рекомендуется использовать СвойствоСоответствия
Функция ЗначениеСоответствия(знач ИмяСвойства, знач Соответствие, знач ПоУмолчанию = Неопределено, знач КакЧисло = Ложь) Экспорт 
	Возврат СвойствоСоответствия(Соответствие, ИмяСвойства, ПоУмолчанию, КакЧисло);
КонецФункции

// Устарела. Функционал не используется. Свойство СвернутыйЗаголовок отсутствует
//
// Установливает заголовок для группы, в зависимости от текущего режима клиента
//
// Параметры:
//	Форма		- ФормаКлиентскогоПриложения
//	ИмяГруппы	- Строка
//	Заголовок	- Строка
// 
Процедура УстановитьЗаголовокГруппы(Форма, знач ИмяГруппы, знач Заголовок) Экспорт
	
	#Если ВебКлиент Тогда
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы,
			ИмяГруппы, "СвернутыйЗаголовок", Заголовок);
	#Иначе
		ОбщегоНазначенияКлиентСервер.УстановитьСвойствоЭлементаФормы(Форма.Элементы,
			ИмяГруппы, "ЗаголовокСвернутогоОтображения", Заголовок);
	#КонецЕсли
	
КонецПроцедуры

// Устарела. Рекомендуется использовать методы КонструкторПредставленияКлиентСервер
//
// Возвращает структуру по перечню указанных полей из структуры переданных данных
//	Пример:
//		Процедура ВывестиПредставлениеОрганизации(знач КонтрагентСсылка)
//			Порядок		= "Наименование,ИНН,КПП";
//			Префиксы	= Новый Структура("ИНН,КПП", " ИНН/КПП", "/");
//			Данные		= Новый Структура("Наименование,ИНН,КПП",
//				КонтрагентСсылка.Наименование,
//				КонтрагентСсылка.ИНН,
//				КонтрагентСсылка.КПП);
//
//			СформироватьПредставлениеПоСтруктуре(Данные, Порядок, Префиксы);
//		КонецПроцедуры;
//
// Параметры:
//	Данные		- Структура - имя и значение поля для представления
//	Порядок		- Строка - порядок полей для формирования представления
//	Префиксы	- Структура - набор префиксов для полей при формировании представления
//		Префиксы должны содержать пробелы, если они необходимы с точки зрения вывода данных
//
// Возвращаемое значение:
//   Строка
//
Функция СформироватьПредставлениеПоСтруктуре(знач Данные, знач Порядок, знач Префиксы = Неопределено) Экспорт 
	Настройки = Новый Соответствие;
	
	Для Каждого КлючИЗначение Из Префиксы Цикл
		КонструкторПредставленияКлиентСервер.УстановитьПрефикс(Настройки, КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат КонструкторПредставленияКлиентСервер.ПодготовитьПредставление(Данные, Порядок, Настройки);
КонецФункции

#КонецОбласти 