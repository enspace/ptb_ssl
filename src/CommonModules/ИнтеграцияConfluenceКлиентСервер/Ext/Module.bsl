// Copyright (c) 2023, ООО ПрогТехБизнес
// Лицензия Attribution 4.0 International (CC BY 4.0)

#Область СтруктурыДанных

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = userdata
//		Имя				- Строка
//		Ключ			- Строка
//		Тип				- Строка - known, unknown, anonymous, user
//		АдресEMail		- Строка
//		КраткоеИмя		- Строка
//		ПолноеИмя		- Строка
//		Аккаунт			- Структура
//			Идентификатор	- Строка
//			Тип				- Строка - atlassian, app
//
Функция Структура_userdata(знач Соответствие)
	СтруктураАккаунт = Новый Структура;
	СтруктураАккаунт.Вставить("Идентификатор"	, СвойствоСоответствия(Соответствие, "accountId", ""));
	СтруктураАккаунт.Вставить("Тип"				, СвойствоСоответствия(Соответствие, "accountType", ""));
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "userdata");
	Результат.Вставить("Имя"				, СвойствоСоответствия(Соответствие, "username", ""));
	Результат.Вставить("Ключ"				, СвойствоСоответствия(Соответствие, "userKey", ""));
	Результат.Вставить("Тип"				, СвойствоСоответствия(Соответствие, "type", ""));
	Результат.Вставить("АдресEMail"			, СвойствоСоответствия(Соответствие, "email", ""));
	Результат.Вставить("КраткоеИмя"			, СвойствоСоответствия(Соответствие, "publicName", ""));
	Результат.Вставить("ПолноеИмя"			, СвойствоСоответствия(Соответствие, "displayName", "")); 
	Результат.Вставить("Аккаунт"			, СтруктураАккаунт);
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = version
//		Пользователь	- Структура - type = userdata
//		ДатаИзменения	- Дата
//		Описание		- Строка
//		Номер			- Число
//		НеСущественное	- Булево
//
Функция Структура_version(знач Соответствие)
	ДанныеПользователь = СвойствоСоответствия(Соответствие, "by", Новый Соответствие);
	
	СтруктураПользователь = Структура_userdata(ДанныеПользователь);
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "version");
	Результат.Вставить("Пользователь"		, СтруктураПользователь);
	Результат.Вставить("ДатаИзменения"		, ДатаИзЗначения(Соответствие, "when"));
	Результат.Вставить("Описание"			, СвойствоСоответствия(Соответствие, "message", ""));
	Результат.Вставить("Номер"				, ЧислоИзЗначения(Соответствие, "number"));
	Результат.Вставить("НеСущественное"		, БулевоИзЗначения(Соответствие, "minorEdit"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = space
//		Идентификатор		- Строка
//		Ключ				- Строка
//		Наименование		- Строка
//		Описание			- Строка
//		ДомашняяСтраница	- Структура - type = content
//		Общее				- Булево
//		Действующее			- Булево
//		Метки				- Массив
//			Префикс			- Строка
//			Представление	- Строка
//			Идентификатор	- Строка
//			Метка			- Строка
//
Функция Структура_space(знач Соответствие, знач Настройки)
	ТипПространства			= СвойствоСоответствия(Соответствие, "type", "");
	СтатусПространства		= СвойствоСоответствия(Соответствие, "status", "");
	ОписаниеПространства	= СвойствоСоответствия(Соответствие, "description/view/value", "");
	МеткиПространства		= СвойствоСоответствия(Соответствие, "metadata/labels/results", Новый Массив);
	ДомашняяСтраница		= СвойствоСоответствия(Соответствие, "homepage", Неопределено);
	
	МассивМетки = Новый Массив;
	Для Каждого СоответствиеМетки Из МеткиПространства Цикл
		СтруктураМетки = Новый Структура;
		СтруктураМетки.Вставить("Префикс"		, СвойствоСоответствия(СоответствиеМетки, "prefix", ""));
		СтруктураМетки.Вставить("Представление"	, СвойствоСоответствия(СоответствиеМетки, "name", ""));
		СтруктураМетки.Вставить("Идентификатор"	, СвойствоСоответствия(СоответствиеМетки, "id", ""));
		СтруктураМетки.Вставить("Метка"			, СвойствоСоответствия(СоответствиеМетки, "label", ""));
		
		МассивМетки.Добавить(СтруктураМетки);
	КонецЦикла;
	
	Если ДомашняяСтраница <> Неопределено Тогда
		СтруктураДомашняяСтраница = Структура_content(ДомашняяСтраница, Настройки);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "space");
	Результат.Вставить("Идентификатор"		, СвойствоСоответствия(Соответствие, "id", ""));
	Результат.Вставить("Ключ"				, СвойствоСоответствия(Соответствие, "key", ""));
	Результат.Вставить("Наименование"		, СвойствоСоответствия(Соответствие, "name", ""));
	Результат.Вставить("Описание"			, ЗаменитьСпецСимволыHTML(ОписаниеПространства));
	Результат.Вставить("ДомашняяСтраница"	, СтруктураДомашняяСтраница);
	Результат.Вставить("Общее"				, (ТипПространства = "global"));
	Результат.Вставить("Действующее"		, (СтатусПространства = "current"));
	Результат.Вставить("Метки"				, МассивМетки);
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = spacearray
//		Значения		- Массив
//			Элемент массива Структура: type = space
//		Начало			- Число
//		Ограничение		- Число
//		РазмерВыборки	- Число
//
Функция Структура_spacearray(знач Соответствие, знач Настройки)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеПространство Из ДанныеРезультат Цикл
		СтруктураПространство = Структура_space(СоответствиеПространство, Настройки);
		МассивРезультат.Добавить(СтруктураПространство);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "spacearray");
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие	- Соответствие
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//
// Возвращаемое значение:
//	Структура: type = content
//		Идентификатор	- Строка
//		ТипДанных		- ПеречислениеСсылка.ТипыДанныхConfluence
//		Заголовок		- Строка
//		Статус			- Строка - статус контента
//		Ссылка			- Строка
//		Пространство	- Структура - type = space
//		Версия			- Структура - type = version
//		Ссылки			- Структура - type = links
//
Функция Структура_content(знач Соответствие, знач Настройки)
	ДанныеПространство	= СвойствоСоответствия(Соответствие, "space", Неопределено);
	ДанныеВерсия		= СвойствоСоответствия(Соответствие, "version", Неопределено);
	ДанныеСсылки		= СвойствоСоответствия(Соответствие, "_links", Неопределено);
	
	Если ДанныеПространство <> Неопределено Тогда
		СтруктураПространство = Структура_space(ДанныеПространство, Настройки);
	КонецЕсли;
	Если ДанныеВерсия <> Неопределено Тогда
		СтруктураВерсия = Структура_version(ДанныеВерсия);
	КонецЕсли;
	Если ДанныеСсылки <> Неопределено Тогда
		СтруктураСсылки = Структура_links(ДанныеСсылки);
	КонецЕсли;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "content");
	Результат.Вставить("Идентификатор"		, СвойствоСоответствия(Соответствие, "id", ""));
	Результат.Вставить("ТипДанных"			, ТипДанныхИзЗначения(Соответствие, "type"));
	Результат.Вставить("Статус"				, СвойствоСоответствия(Соответствие, "status", ""));
	Результат.Вставить("Заголовок"			, СвойствоСоответствия(Соответствие, "title", ""));
	Результат.Вставить("Ссылка"				, АдресСсылкиИзЗначения(Соответствие, "url", Настройки.АдресСервераWiki));
	Результат.Вставить("Пространство"		, СтруктураПространство);
	Результат.Вставить("Версия"				, СтруктураВерсия);
	Результат.Вставить("Ссылки"				, СтруктураСсылки);
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие	- Соответствие
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//
// Возвращаемое значение:
//	Структура: type = searchresult
//		Значения		- Массив - type = space
//			Контент			- Структура - type = content
//				Только свойства: Идентификатор, ТипДанных, Статус, Заголовок, Ссылки
//			Пространство	- Структура
//				Заголовок	- Строка
//				Ссылка		- Строка
//			Заголовок		- ФорматированнаяСтрока, Строка
//			Описание		- ФорматированнаяСтрока, Строка
//			Ссылка			- Строка
//			Навигация		- Массив - элемент Структура type = breadcrumb
//			ТипДанных		- ПеречислениеСсылка.ТипыДанныхConfluence
//			Обновлено		- Дата - дата (с временем) обновления
//		Начало			- Число - номер строки выборки (нумерация начинается с 0)
//		Ограничение		- Число - количество строк запроса (ПараметрыПоиска.Размер)
//		РазмерВыборки	- Число - количество строк в выборке
//		ВсегоКоличество	- Число - всего найденных строк
//		СтрокаЗапроса	- Строка - строка запроса для повторного выполнения
//		ВремяПоиска		- Число - время выполнения запроса
//
Функция Структура_searchresult(знач Соответствие, знач Настройки)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	ДанныеСсылки	= СвойствоСоответствия(Соответствие, "_links", Новый Соответствие);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеРезультат Из ДанныеРезультат Цикл
		ДанныеКонтента		= СвойствоСоответствия(СоответствиеРезультат, "content", Новый Соответствие);
		ДанныеПространства	= СвойствоСоответствия(СоответствиеРезультат, "resultGlobalContainer", Новый Соответствие);
		ДанныеНавигация		= СвойствоСоответствия(СоответствиеРезультат, "breadcrumbs", Новый Массив);
		
		СтруктураПространство = Новый Структура;
		СтруктураПространство.Вставить("Заголовок"	, СвойствоСоответствия(ДанныеПространства, "title", ""));
		СтруктураПространство.Вставить("Ссылка"		, АдресСсылкиИзЗначения(ДанныеПространства, "displayUrl", Настройки.АдресСервераWiki));
		
		ЗначениеЗаголовок	= СвойствоСоответствия(СоответствиеРезультат, "title", "");
		ЗначениеОписание	= СвойствоСоответствия(СоответствиеРезультат, "excerpt", "");
		МассивНавигация		= Массив_breadcrumbs(ДанныеНавигация);
		
		СтруктураКонтент = Структура_content(ДанныеКонтента, Настройки);
		СтруктураКонтент.Ссылки.Основа = СвойствоСоответствия(ДанныеСсылки, "base", "");
		
		СтруктураЗначение = Новый Структура;
		СтруктураЗначение.Вставить("Контент"		, СтруктураКонтент);
		СтруктураЗначение.Вставить("Пространство"	, СтруктураПространство);
		СтруктураЗначение.Вставить("Заголовок"		, ФорматироватьСтроку(ЗначениеЗаголовок));
		СтруктураЗначение.Вставить("Описание"		, ФорматироватьСтроку(ЗначениеОписание));
		СтруктураЗначение.Вставить("Ссылка"			, АдресСсылкиИзЗначения(СоответствиеРезультат, "url", Настройки.АдресСервераWiki));
		СтруктураЗначение.Вставить("Навигация"		, МассивНавигация); 
		СтруктураЗначение.Вставить("ТипДанных"		, ТипДанныхИзЗначения(СоответствиеРезультат, "entityType"));
		СтруктураЗначение.Вставить("Обновлено"		, ДатаИзЗначения(СоответствиеРезультат, "lastModified"));
		
		МассивРезультат.Добавить(СтруктураЗначение);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "searchresult");
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	Результат.Вставить("ВсегоКоличество"	, ЧислоИзЗначения(Соответствие, "totalSize"));
	Результат.Вставить("СтрокаЗапроса"		, СвойствоСоответствия(Соответствие, "cqlQuery", ""));
	Результат.Вставить("ВремяПоиска"		, ЧислоИзЗначения(Соответствие, "searchDuration"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = versions
//		Значения		- Массив - type = version
//		Начало			- Число - номер строки выборки
//		Ограничение		- Число - количество строк запроса
//		РазмерВыборки	- Число - количество строк в выборке
//
Функция Структура_versions(знач Соответствие)
	ДанныеРезультат = СвойствоСоответствия(Соответствие, "results", Новый Массив);
	
	МассивРезультат = Новый Массив;
	Для Каждого СоответствиеРезультат Из ДанныеРезультат Цикл
		СтруктураВерсия = Структура_version(СоответствиеРезультат);
		МассивРезультат.Добавить(СтруктураВерсия);
	КонецЦикла;
	
	Результат = Новый Структура;
	Результат.Вставить("type"				, "versions");
	Результат.Вставить("Значения"			, МассивРезультат);
	Результат.Вставить("Начало"				, ЧислоИзЗначения(Соответствие, "start"));
	Результат.Вставить("Ограничение"		, ЧислоИзЗначения(Соответствие, "limit"));
	Результат.Вставить("РазмерВыборки"		, ЧислоИзЗначения(Соответствие, "size"));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Структура: type = links
//		Редактирование	- Строка - ссылка для редактирования статьи (без учета основного адреса)
//		Просмотр		- Строка - ссылка для просмотра статьи (без учета основного адреса)
//		Сокращенная		- Строка - краткая ссылка для просмотра статьи (без учета основного адреса)
//		Основа			- Строка - основной адрес расположения базы знаний
//
Функция Структура_links(знач Соответствие)
	Результат = Новый Структура;
	Результат.Вставить("type"				, "links");
	Результат.Вставить("Редактирование"		, СвойствоСоответствия(Соответствие, "editui", ""));
	Результат.Вставить("Просмотр"			, СвойствоСоответствия(Соответствие, "webui", ""));
	Результат.Вставить("Сокращенная"		, СвойствоСоответствия(Соответствие, "tinyui", ""));
	Результат.Вставить("Основа"				, СвойствоСоответствия(Соответствие, "base", ""));
	
	Возврат Результат;
КонецФункции

// Возвращает структуру с данным ошибки
//
// Параметры:
//	ОтветHTTP	- HTTPОтвет
//	ДопТекст	- Строка
//
// Возвращаемое значение:
//	Структура: type = error
//		Код			- Число
//		Текст		- Строка
//		ДопТекст	- Строка
// 
Функция Структура_error(знач ОтветHTTP, знач ДопТекст = "")
	ТекстОшибки	= ОтветHTTP.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
	КодОшибки	= ОтветHTTP.КодСостояния;
	
	Возврат Новый Структура("type, Код, Текст, ДопТекст",
	    "error",
		КодОшибки,
		ТекстОшибки,
		ДопТекст);
КонецФункции

// Возвращает структуру со статусом "Выполнено"
//
// Параметры:
//	ОтветHTTP	- HTTPОтвет
//	ДопТекст	- Строка
//
// Возвращаемое значение:
//	Структура: type = done
//		Код			- Число
//		ДопТекст	- Строка
// 
Функция Структура_done(знач ОтветHTTP, знач ДопТекст = "")
	КодВыполнения = ОтветHTTP.КодСостояния;
	
	Возврат Новый Структура("type, Код, ДопТекст",
	    "done",
		КодВыполнения,
		ДопТекст);
КонецФункции

// Возвращает массив с данными из соответствия (ответ от Confluence)
//
// Параметры:
//	Соответствие - Соответствие
//
// Возвращаемое значение:
//	Массив: Структура: 
//		type		= breadcrumb
//		Заголовок	- Строка
//		Ссылка		- Строка
//		Разделитель	- Строка
//
Функция Массив_breadcrumbs(знач Массив)
	МассивНавигация = Новый Массив;
	
	Для Каждого Соответствие Из Массив Цикл
		СтруктураНавигация = Новый Структура;
		СтруктураНавигация.Вставить("type"			, "breadcrumb");
		СтруктураНавигация.Вставить("Заголовок"		, СвойствоСоответствия(Соответствие, "label", ""));
		СтруктураНавигация.Вставить("Ссылка"		, СвойствоСоответствия(Соответствие, "url", ""));
		СтруктураНавигация.Вставить("Разделитель"	, СвойствоСоответствия(Соответствие, "separator", ""));
		
		МассивНавигация.Добавить(СтруктураНавигация);
	КонецЦикла;
	
	Возврат МассивНавигация;
КонецФункции

#КонецОбласти 
 
#Область ПрограммныйИнтерфейс

// Возвращает текущие данные пользователя
//
// Параметры:
//	Настройки - Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//
// Возвращаемое значение:
//   Структура: type = userData
// 
Функция ПолучитьТекущегоПользователя(знач Настройки) Экспорт
	ТекстЗапроса = "/wiki/rest/api/user/current";
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение данных текущего пользователя.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_userdata(ДанныеОтвета);
КонецФункции

// Выполняет поиск данных в базе знаний по переданным условиям
//
// Параметры:
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	НастройкаПоиска	- Структура, Строка
//		- Структура - строка запроса будет сформирована автоматически, формат структуры
//			см. ИнтеграцияConfluenceКлиентСервер.НастройкаПоиска
//		- Строка - запрос будет выполнен по ней без доп. обработки, строка запроса может
//			быть получена из результата поиска или из метода ПолучитьСтрокуЗапросаПоиска
//	ПараметрыПоиска	- Структура - см. ИнтеграцияConfluenceКлиентСервер.ПараметрыПоиска
//
// Возвращаемое значение:
//   Структура: type = searchresult
// 
Функция Поиск(знач Настройки, знач НастройкаПоиска, знач ПараметрыПоиска = Неопределено) Экспорт
	ТипНастройкаПоиска = ТипЗнч(НастройкаПоиска);
	Если ТипНастройкаПоиска = Тип("Структура") Тогда
		СтрокаЗапроса = СформироватьСтрокуПоискаПоНастройке(НастройкаПоиска);
	ИначеЕсли ТипНастройкаПоиска = Тип("Строка") Тогда 
		СтрокаЗапроса = НастройкаПоиска;
	Иначе 
		ВызватьИсключение СтрШаблон(НСтр("ru='Неверно передан параметр ""НастройкаПоиска"" (%1)'"), Строка(ТипНастройкаПоиска));
	КонецЕсли;
	
	Если НЕ ЗначениеЗаполнено(СтрокаЗапроса) Тогда
		ВызватьИсключение НСтр("ru='Не заданы настройки поиска.'");
	КонецЕсли;
	
	РежимОтладки = СвойствоСтруктуры(ПараметрыПоиска, "РежимОтладки", Ложь);
	Если РежимОтладки Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(НСтр("ru='CQL запрос к Confluence: '") + СтрокаЗапроса);
	КонецЕсли;
	
	СтрокаПараметры = СтрокаПараметровПоиск(ПараметрыПоиска);
	
	ТекстЗапроса = "/wiki/rest/api/search?cql=" + СтрокаЗапроса + СтрокаПараметры;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Поиск данных в базе знаний.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_searchresult(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает все пространства. Список упорядочен в алфавитном порядке в порядке возрастания по ключу
//
// Параметры:
//	Настройки			- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	ПараметрыЗапроса	- Структура	- см. ИнтеграцияConfluenceКлиентСервер.ПараметрыПолучитьПространства
//
// Возвращаемое значение:
//   Структура - type = spacearray
// 
Функция ПолучитьПространства(знач Настройки, знач ПараметрыЗапроса = Неопределено) Экспорт
	СтрокаПараметры		= СтрокаПараметровПолучитьПространства(ПараметрыЗапроса);
	СтрокаСоединение	= ?(ПустаяСтрока(СтрокаПараметры), "", "&");
	
	ТекстЗапроса = "/wiki/rest/api/space?expand=description.view,metadata.labels,homepage" + СтрокаСоединение + СтрокаПараметры;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение данных текущего пользователя.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_spacearray(ДанныеОтвета, Настройки);
КонецФункции

// Создает контент согласно переданным настройкам. В случае удачного выполнения возвращает данные контента
//
// Параметры:
//	Настройки	- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Контент		- Структура	- см. СтруктураСтатьи, СтруктураЗаписиБлога
//
// Возвращаемое значение:
//   Структура - type = content
// 
Функция СоздатьКонтент(знач Настройки, знач Контент) Экспорт
	Если НЕ ТипЗнч(Контент) = Тип("Структура")
		И НЕ ТипЗнч(Контент) = Тип("ФиксированнаяСтруктура") Тогда
		ВызватьИсключение НСтр("ru='Неверно передан параметр ""Контент"".'");
	ИначеЕсли СвойствоСтруктуры(Контент, "type") <> "page"
		И СвойствоСтруктуры(Контент, "type") <> "blogpost" Тогда
		ВызватьИсключение НСтр("ru='Параметр ""Контент"" не соответствует требованию.'");
	КонецЕсли;
	
	ТекстЗапроса = "/wiki/rest/api/content?expand=description.view,metadata.labels,version,body.storage";
	
	#Область СтрокаJSON
	МассивРодители = Новый Массив;
	Если НЕ ПустаяСтрока(Контент.Родитель) Тогда
		МассивРодители.Добавить(Новый Структура("id", Контент.Родитель));
	КонецЕсли;
	
	СтрокаStorage = ПолучитьСтрокуConfluenceStorage(Контент);
	
	СтруктураПространство = Новый Структура;
	СтруктураПространство.Вставить("key", Контент.Пространство);
	
	СтруктураХранилище = Новый Структура;
	СтруктураХранилище.Вставить("value"				, СтрокаStorage);
	СтруктураХранилище.Вставить("representation"	, "storage");
	
	СтруктураТело = Новый Структура;
	СтруктураТело.Вставить("storage", СтруктураХранилище);
	
	СтруктураДанных = Новый Структура;
	СтруктураДанных.Вставить("type"			, Контент.type);
	СтруктураДанных.Вставить("status"		, "current");
	СтруктураДанных.Вставить("title"		, Контент.Заголовок);
	СтруктураДанных.Вставить("body"			, СтруктураТело);
	СтруктураДанных.Вставить("space"		, СтруктураПространство);
	СтруктураДанных.Вставить("ancestors"	, МассивРодители);
	
	СтрокаJSON = ПолучитьСтрокуJSON(СтруктураДанных);
	#КонецОбласти 
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	ЗапросHTTP.УстановитьТелоИзСтроки(СтрокаJSON);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		ТекстОшибки = СтрШаблон(НСтр("ru='Создание нового контента (%1)'"), Контент.type);
		Возврат Структура_error(ОтветHTTP, ТекстОшибки);
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_content(ДанныеОтвета, Настройки);
КонецФункции

// Изменяет контент согласно переданным настройкам. В случае удачного выполнения возвращает данные контента
//
// Параметры:
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Идентификатор	- Строка
//	КонтентСтатус	- Структура, Строка
//		Для установки нового контента статьи передается структура контента
// 		Для изменения только статуса контента необходимо передать значение статуса:
//			Текущая 	- изменение статуса на current
//			Удалена		- изменение статуса на trashed
//			Устарела	- изменение статуса на historical
//			Черновик	- изменение статуса на draft
// 
// Для других изменений необходимо передавать структуру. * - обязательные поля
//	* type			- Структура - предопределенный: page, blogpost
//	* Версия			- Число - номер версии. Используется только при изменении статьи
//	* Заголовок		- Строка - значение заголовка статьи, не должно повторяться в рамках пространства
//	Тело			- Массив - вложенные структуры с элементами тела статьи
//	Статус			- Строка - статус статьи. Используется только при изменении статьи
//	Пространство	- Строка - ключ пространства
//	Родитель		- Строка - идентификатор статьи родителя
//
// Возвращаемое значение:
//   Структура - type = content
// 
Функция ИзменитьКонтент(знач Настройки, знач Идентификатор, знач КонтентСтатус) Экспорт
	ТипКонтент =  ТипЗнч(КонтентСтатус);
	Если НЕ ТипКонтент = Тип("Структура") И НЕ ТипКонтент = Тип("ФиксированнаяСтруктура") И НЕ ТипКонтент = Тип("Строка") Тогда
		ВызватьИсключение НСтр("ru='Неверно передан параметр ""Контент"".'");
	КонецЕсли;
	
	СтрокаСтатус	= "";
	СтрокаJSON		= "";
		
	ИзменитьСтатус	= (ТипЗнч(КонтентСтатус) = Тип("Строка"));
	
	#Область СтрокаJSON
	Если ИзменитьСтатус Тогда
		СтатусConfluence = СтатусВСтроку(КонтентСтатус);
		Если ПустаяСтрока(СтатусConfluence) Тогда
			ВызватьИсключение НСтр("ru='Неверно передан параметр ""Статус"" для изменения.'"); 
		КонецЕсли;
		
		СтрокаСтатус = "status=" + СтатусConfluence + "&";
	Иначе 
		СтруктураВерсия = Новый Структура("number", Формат(КонтентСтатус.Версия, "ЧН=0; ЧГ="));
		
		СтруктураДанных = Новый Структура;
		СтруктураДанных.Вставить("version"		, СтруктураВерсия);
		СтруктураДанных.Вставить("title"		, КонтентСтатус.Заголовок);
		СтруктураДанных.Вставить("type"			, КонтентСтатус.type);
		
		ЗначениеСтатус			= СвойствоСтруктуры(КонтентСтатус, "Статус", "");
		ЗначениеТело			= СвойствоСтруктуры(КонтентСтатус, "Тело", Неопределено);
		ЗначениеПространство	= СвойствоСтруктуры(КонтентСтатус, "Пространство", "");
		ЗначениеРодитель		= СвойствоСтруктуры(КонтентСтатус, "Родитель", "");
		
		Если НЕ ПустаяСтрока(ЗначениеСтатус) Тогда
			СтатусConfluence = СтатусВСтроку(ЗначениеСтатус);
			
			СтруктураДанных.Вставить("status", СтатусConfluence);
		КонецЕсли;
		
		Если ЗначениеТело <> Неопределено Тогда
			СтрокаStorage = ПолучитьСтрокуConfluenceStorage(КонтентСтатус);
			
			СтруктураХранилище = Новый Структура;
			СтруктураХранилище.Вставить("value"				, СтрокаStorage);
			СтруктураХранилище.Вставить("representation"	, "storage");
			
			СтруктураТело = Новый Структура;
			СтруктураТело.Вставить("storage", СтруктураХранилище);
			
			СтруктураДанных.Вставить("body", СтруктураТело);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ЗначениеПространство) Тогда
			СтруктураПространство = Новый Структура;
			СтруктураПространство.Вставить("key", ЗначениеПространство);
			
			СтруктураДанных.Вставить("space", СтруктураПространство);
		КонецЕсли;
		
		Если НЕ ПустаяСтрока(ЗначениеРодитель) Тогда
			МассивРодители = Новый Массив;
			МассивРодители.Добавить(Новый Структура("id", ЗначениеРодитель));
			
			СтруктураДанных.Вставить("ancestors", МассивРодители);
		КонецЕсли;
		
		СтрокаJSON = ПолучитьСтрокуJSON(СтруктураДанных);
	КонецЕсли;
	#КонецОбласти 
	
	ТекстЗапроса = СтрШаблон("/wiki/rest/api/content/%1?%2expand=description.view,metadata.labels,version,body.storage", Идентификатор, СтрокаСтатус);
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	ЗапросHTTP.УстановитьТелоИзСтроки(СтрокаJSON);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Записать(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		ТекстОшибки = СтрШаблон(НСтр("ru='Изменение контента (%1)'"), Идентификатор);
		Возврат Структура_error(ОтветHTTP, ТекстОшибки);
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_content(ДанныеОтвета, Настройки);
КонецФункции

// Выполняет удаление контента из базы знаний. Для полного удаления статьи (записи блога)
// необходимо предварительно ее переместить в корзину, а затем удалять полностью
//
// Параметры:
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Идентификатор	- Строка
//	ВКорзину		- Булево - если установлено Истина статья будет перемещена в корзину
//							   и может быть восстановлена
//
// Возвращаемое значение:
//   Структура - type = done
// 
Функция УдалитьКонтент(знач Настройки, знач Идентификатор, знач ВКорзину = Ложь) Экспорт
	СтрокаСтатус = ?(ВКорзину = Истина, "", "?status=trashed");
	
	ТекстЗапроса = "/wiki/rest/api/content/" + Идентификатор + СтрокаСтатус;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Удалить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 И ОтветHTTP.КодСостояния <> 204 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Удаление контента.'"));
	КонецЕсли;
	
	Возврат Структура_done(ОтветHTTP, НСтр("ru='Удаление контента'"));
КонецФункции

// Возвращает полные данные контента по идентификатору
//
// Параметры:
//	Настройки - Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Идентификатор	- Строка
//
// Возвращаемое значение:
//   Структура - type = content
// 
Функция ПолучитьКонтентПоИдентификатору(знач Настройки, знач Идентификатор) Экспорт
	ТекстЗапроса = "/wiki/rest/api/content/" + Идентификатор + "?expand=description.view,metadata.labels,version,body.storage,ancestors";
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение данных текущего пользователя.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_content(ДанныеОтвета, Настройки);
КонецФункции

// Возвращает данные версий указанного контента (статья, запись блога)
//
// Параметры:
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Идентификатор	- Строка
//
// Возвращаемое значение:
//   Структура: type = versions
// 
Функция ПолучитьВерсииКонтента(знач Настройки, знач Идентификатор) Экспорт
	ТекстЗапроса = "/wiki/rest/api/content/" + Идентификатор + "/version"; //?expand=description.view,metadata.labels,version,body.storage";
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Получить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Получение версий контента'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_versions(ДанныеОтвета);
КонецФункции

// Выполняет удаление версии контента из базы знаний
//
// Параметры:
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Идентификатор	- Строка
//	НомерВерсии		- Число, Строка - номер версии для удаления
//
// Возвращаемое значение:
//   Структура - type = done
// 
Функция УдалитьВерсиюКонтента(знач Настройки, знач Идентификатор, знач НомерВерсии) Экспорт
	СтрокаВерсия = ?(ТипЗнч(НомерВерсии) = Тип("Число"), Формат(НомерВерсии, "ЧН=0; ЧГ="), НомерВерсии);
	
	ТекстЗапроса = "/wiki/rest/api/content/" + Идентификатор + "/" + СтрокаВерсия;
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP	= ПолучитьЗаголовки(Настройки);
	ЗапросHTTP		= Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	СоединениеHTTP	= ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 
	
	ОтветHTTP = СоединениеHTTP.Удалить(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Удаление версии контента.'"));
	КонецЕсли;
	
	Возврат Структура_done(ОтветHTTP, НСтр("ru='Удаление версии контента'"));
КонецФункции

// Добавляет или изменяет файл вложение для указанного контента по идентификатору
// Следует учитывать, имя файла должно быть уникальным в рамках контента
//
// Параметры:
//	Настройки		- Структура - см. ИнтеграцияConfluenceВызовСервера.НастройкиПодключения
//	Идентификатор	- Строка
//	ДанныеФайла		- Структура
//		Данные		- ДвоичныеДанные - данные вложения
//		ИмяФайла	- Строка - имя файла с расширением
//		* Расширение	- ФорматКартинки, Строка - не обязательно, будет считано из имени
//
// Возвращаемое значение:
//   Структура - type = content
// 
Функция ДобавитьВложение(знач Настройки, знач Идентификатор, знач ДанныеФайла) Экспорт
	Разделитель = Формат(ТекущаяУниверсальнаяДатаВМиллисекундах(), "ЧГ=");
	
	ТекстЗапроса = "/wiki/rest/api/content/" + Идентификатор + "/child/attachment";
		
	#Область ДвоичныеДанные
	ДанныеФормы = СтрШаблон("name=""file""; filename=""%1""; minorEdit=true", ДанныеФайла.ИмяФайла);
	ТипКонтента	= ПолучитьТипКонтентаПоРасширению(ДанныеФайла.Расширение, ДанныеФайла.ИмяФайла);

	ПотокВПамятиТело = Новый ПотокВПамяти;
	
	ЗаписьДанных = Новый ЗаписьДанных(ПотокВПамятиТело);
	ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель);
	ЗаписьДанных.ЗаписатьСтроку("Content-Disposition: form-data; " + ДанныеФормы);
	ЗаписьДанных.ЗаписатьСтроку("Content-Type: " + ТипКонтента);
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.Записать(ДанныеФайла.Данные);
	ЗаписьДанных.ЗаписатьСтроку("");
	ЗаписьДанных.ЗаписатьСтроку("--" + Разделитель + "--");
	ЗаписьДанных.Закрыть();
	
	ДвоичныеДанные = ПотокВПамятиТело.ЗакрытьИПолучитьДвоичныеДанные();
	
	РазмерДанных = ДвоичныеДанные.Размер();
	#КонецОбласти 
	
	#Область ЗапросHTTP
	ЗаголовкиHTTP = ПолучитьЗаголовки(Настройки);
	ЗаголовкиHTTP.Вставить("X-Atlassian-Token"	, "nocheck"); 
	ЗаголовкиHTTP.Вставить("Content-Type"		, "multipart/form-data; boundary=" + Разделитель);
	ЗаголовкиHTTP.Вставить("Content-Lenght"		, РазмерДанных);	
	
	ЗапросHTTP = Новый HTTPЗапрос(ТекстЗапроса, ЗаголовкиHTTP);
	ЗапросHTTP.УстановитьТелоИзДвоичныхДанных(ДвоичныеДанные);
	
	СоединениеHTTP = ПолучитьСоединениеHTTP(Настройки);
	#КонецОбласти 

	ОтветHTTP = СоединениеHTTP.ОтправитьДляОбработки(ЗапросHTTP);
	Если ОтветHTTP.КодСостояния <> 200 Тогда
		Возврат Структура_error(ОтветHTTP, НСтр("ru='Создание вложения.'"));
	КонецЕсли;
	
	ДанныеОтвета = СоответствиеИзОтвета(ОтветHTTP);
	Возврат Структура_content(ДанныеОтвета, Настройки);
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Дополнительно

Функция ПараметрыПолучитьПространства() Экспорт
	Структура = Новый Структура;
	Структура.Вставить("Общие"		, Неопределено); // Истина - общие (global), Ложь - персональные (personal), Неопределено - все
	Структура.Вставить("Действующие", Неопределено); // Истина - действующие (current), Ложь - архивные (archived), Неопределено - все
	Структура.Вставить("Метка"		, "");
	Структура.Вставить("Избранное"	, Ложь);
	
	Возврат Структура; 
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Поиск

// Добавляет элемент поиска в группу или настройку отбора
//
// Параметры:
//	ГруппаПоиска		- Структура - searchdata, searchgroup
//	ПолеПоиска			- Строка - см. ЭлементНастройкиПоиска
//	УсловиеСравнения	- ВидСравненияКомпоновкиДанных - см. ЭлементНастройкиПоиска
//	Значение			- Произвольный - см. ЭлементНастройкиПоиска
// 
Процедура ДобавитьЭлементПоиска(ГруппаПоиска, знач ПолеПоиска, знач УсловиеСравнения, знач Значение) Экспорт
	ЭлементПоиска = ЭлементНастройкиПоиска(ПолеПоиска, УсловиеСравнения, Значение);
	ГруппаПоиска.Элементы.Добавить(ЭлементПоиска);
КонецПроцедуры

// Возвращает параметры поиска
//
// Возвращаемое значение:
//   Структура
//		type			- Строка - searchparams
//		Начало			- Число - начальная строка выборки (нумерация начинается с 1)
//		Размер			- Число - размер выборки
//		Архив			- Булево - искать в архивных пространствах
//		РежимОтладки	- Булево - во время режима отладки выводится текст запроса для поиска
// 
Функция ПараметрыПоиска(знач Начало = 1, знач Размер = 25, знач Архив = Ложь) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("type"	, "searchparams");
	Структура.Вставить("Начало"	, Начало);
	Структура.Вставить("Размер"	, Размер);
	Структура.Вставить("Архив"	, Архив);
	
	Структура.Вставить("РежимОтладки", Ложь);

	Возврат Структура;
КонецФункции

// Возвращает настройку поиска
//
// Возвращаемое значение:
//   Структура
//		type		- Строка - searchData
//		Элементы	- Массив - массив групп и элементов настроек поиска
//		Порядок		- Массив - массив имен элементов для упорядочивания запроса
//			Не поддерживаемые поля: Пространство, ВИерархии, Родитель, Текст 
// 
Функция НастройкаПоиска() Экспорт
	Структура = Новый Структура;
	Структура.Вставить("type"		, "searchdata");
	Структура.Вставить("Элементы"	, Новый Массив);
	Структура.Вставить("Порядок"	, Новый Массив);
	
	Возврат Структура;
КонецФункции

// Возвращает структуру группы поиска
//
// Параметры:
//	ГруппаИЛИ - Строка, Булево - ИЛИ (Истина), И (Ложь)
//
// Возвращаемое значение:
//   Структура
//		type		- Строка - searchgroup
//		ТипГруппы	- ТипГруппыЭлементовОтбораКомпоновкиДанных - И, ИЛИ
//		Элементы	- Массив
// 
Функция ГруппаНастройкиПоиска(знач ГруппаИЛИ = Ложь) Экспорт
	Структура = Новый Структура;
	Структура.Вставить("type"		, "searchgroup");
	Структура.Вставить("ТипГруппы"	, ?(ГруппаИЛИ = Истина ИЛИ ВРег(ГруппаИЛИ) = "ИЛИ",
		ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли,
		ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИ));
	Структура.Вставить("Элементы"	, Новый Массив);
	
	Возврат Структура;
КонецФункции

// Возвращает структуру элемента поиска
// Особенности работы:
//	- confluence поддерживает поиск по одному или нескольким произвольным символам в строке:
//		* поиск по одному свободному символу - «?» (например: "?рест" - "крест", "трест" и т.д.)
//		* поиск по нескольким свободным символам - «*» (например: "лог*" - "логово", "логарифм" и т.д.)
//	- confluence поддерживает нечеткий поиск. Для нечеткого поиска используйте тильду, символ (~) в конце одного слова
//	- вид сравнения "Содержит" и "Не содержит" может быть использован только для полей "Текст", "Заголовок"
//		в противном случае будет вызвано исключение.
//	- вид сравнения "Не содержит" используется для поиска содержимого, в котором значение указанного поля не является
//		«нечетким» соответствием указанного значения
//
//	Примеры передачи использования условия "Содержит"
//		* Найти весь контент, где заголовок содержит слово "Победа": Поле = "Заголовок", Значение = "победа"
//		* Найти весь контент, где заголовок содержит свободные символы со словом "побед": Поле = "Заголовок", Значение = "побед*"
//		* Найти весь контент, где где текст содержит слово "продвинутый" и слово "поиск": Поле = "Текст", Значение = "продвинутый поиск"
//
// Параметры:
//	ПолеПоиска			- Строка - предопределенное имя поля поиска
//		ВИерархии		- Строка - отбор по иерархии статей
//		Родитель		- Строка - отбор по родительской статье
//		Заголовок		- Строка - отбор по заголовку
//		Текст			- Строка - отбор по тексту статьи
//		ДатаСоздания	- ДатаВремя - отбор по дате создания
//		ДатаИзменения	- ДатаВремя - отбор по дате изменения
//		Пространство	- Строка - отбор по пространству
//		ТипДанных		- ПеречислениеСсылка.ТипыДанныхConfluence - отбор по типу страницы
//	УсловиеСравнения	- ВидСравненияКомпоновкиДанных
//		Больше/Меньше(ИлиРавно), (Не)ВСписке, (Не)НачинаетсяС, (Не)Равно, (Не)Содержит
//	Значение			- Произвольный, Массив
//
// Возвращаемое значение:
//   Структура
//		type		- Строка - searchgroup
//		Поле		- Строка
//		Условие		- ВидСравненияКомпоновкиДанных
//		Значение	- Произвольный, Массив
// 
Функция ЭлементНастройкиПоиска(знач ПолеПоиска, знач УсловиеСравнения, знач Значение) Экспорт
	Если ВидСравненияНеПоддерживается(УсловиеСравнения) Тогда
		ВызватьИсключение СтрШаблон(НСтр("ru='Вид сравнения ""%1"" не поддерживается.'"), Строка(УсловиеСравнения));
	КонецЕсли;
	
	Структура = Новый Структура;
	Структура.Вставить("type"			, "searchelement");
	Структура.Вставить("Поле"			, ПолеПоиска);
	Структура.Вставить("ВидСравнения"	, УсловиеСравнения);
	Структура.Вставить("Значение"		, Значение);
	
	Возврат Структура;
КонецФункции

#КонецОбласти

#Область ПрограммныйИнтерфейс_Контент

// Возвращает структуру для создания статьи на сайте
//
// Возвращаемое значение:
//   Структура
//		type			- Структура - предопределенный: page
//		ТипДанных		- Перечисление.ТипыДанныхConfluence - предопреленный: Статья
//		Тело			- Массив - вложенные структуры с элементами тела статьи
//			ТегHTML		- Строка - имя HTML тега 
//			Параметры	- Соответствие - параметры блока. Не обязательный
//			Текст		- Строка - вложенный текст. Не обязательный
//			Элементы	- Массив - вложенные элементы. Не обязательный
//		Статус			- Строка - статус статьи. Используется только при изменении статьи
//			Текущая 	- current
//			Удалена		- trashed
//			Устарела	- historical
//			Черновик	- draft
//		Версия			- Число - номер версии. Используется только при изменении статьи
//		Заголовок		- Строка - значение заголовка статьи, не должно повторяться в рамках пространства
//		Пространство	- Строка - ключ пространства
//		Родитель		- Строка - идентификатор статьи родителя
// 
Функция СтруктураСтатьи() Экспорт
	СтруктураЭлемента = СтруктураКонтента("page", ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Статья"));
	СтруктураЭлемента.Вставить("Статус"			, "");
	СтруктураЭлемента.Вставить("Версия"			, 0);
	СтруктураЭлемента.Вставить("Заголовок"		, "");
	СтруктураЭлемента.Вставить("Пространство"	, "");
	СтруктураЭлемента.Вставить("Родитель"		, "");
	
	Возврат СтруктураЭлемента; 
КонецФункции

// Возвращает структуру для создания статьи на сайте
//
// Возвращаемое значение:
//   Структура
//		type			- Структура - предопределенный: blogpost
//		ТипДанных		- Перечисление.ТипыДанныхConfluence - предопреленный: ЗаписьБлога
//		Заголовок		- Строка - значение заголовка статьи, не должно повторяться в рамках пространства
//		Пространство	- Строка - ключ пространства
//		Родитель		- Строка - идентификатор статьи родителя
//		Тело			- Массив - вложенные структуры с элементами тела записи блога
//			ТегHTML		- Строка - имя HTML тега 
//			Параметры	- Соответствие - параметры блока. Не обязательный
//			Текст		- Строка - вложенный текст. Не обязательный
//			Элементы	- Массив - вложенные элементы. Не обязательный
//		Статус			- Строка - статус статьи. Используется только при изменении статьи
//			Текущая 	- current
//			Удалена		- trashed
//			Устарела	- historical
//			Черновик	- draft
//		Версия			- Число - номер версии. Используется только при изменении статьи
// 
Функция СтруктураЗаписиБлока() Экспорт
	СтруктураЭлемента = СтруктураКонтента("blogpost", ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.ЗаписьБлога"));
	СтруктураЭлемента.Вставить("Статус"			, "");
	СтруктураЭлемента.Вставить("Версия"			, 0);
	СтруктураЭлемента.Вставить("Заголовок"		, "");
	СтруктураЭлемента.Вставить("Пространство"	, "");
	СтруктураЭлемента.Вставить("Родитель"		, "");
	
	Возврат СтруктураЭлемента;
КонецФункции

// Возвращает структуру для вставки секции "Блоки"
//
// Пример использования:
//	Блоки = ЭлементСтатьиБлоки();
//	Блок1 = ЭлементСтатьиБлок(2);
//	Блок1.Элементы[0].Элементы.Добавить(ЭлементТекст("Новый текст"));
//	Блок1.Элементы[1].Элементы.Добавить(ЭлементСтатьиСодержание());
//
// HTML:
//	<ac:layout>
//		<ac:layout-section ac:type="single">
//			<ac:layout-cell>
//				{content}
//			</ac:layout-cell>
//		</ac:layout-section>
//	</ac:layout>
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - Строка - ac:layout
// 
Функция ЭлементКонтентаБлоки() Экспорт
	Возврат СтруктураЭлементаСтатьи("ac:layout");
КонецФункции

// Возвращает структуру для вставки секции "Блок".
// При этом в ключе "Элементы" уже созданы элементы колонок
// по количеству согласно указанного типа
//
// Пример использования:
//	Блоки = ЭлементСтатьиБлоки();
//	Блок1 = ЭлементСтатьиБлок(2);
//	Блок1.Элементы[0].Элементы.Добавить(ЭлементТекст("Новый текст"));
//	Блок1.Элементы[1].Элементы.Добавить(ЭлементСтатьиСодержание());
//
// HTML:
//	<ac:layout-section ac:type="single">
//		<ac:layout-cell>
//			{content}
//		</ac:layout-cell>
//	</ac:layout-section>
//
// Параметры:
//	Тип - Число
//		0 - одна колонка по всей ширине
//		1 - две колонки одинаковой ширины
//		2 - две колонки, левая узкая, правая широкая
//		3 - две колонки, левая широкая, правай узкая
//		4 - три колонки одинаковой ширины
//		5 - три колонки, широкая по середине, узкие по краям
//		6 - одна колонка фиксированной ширины
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - ac:layout-section
// 
Функция ЭлементКонтентаБлок(знач Тип = 0) Экспорт
	Параметры = Новый Соответствие;
	Если Тип = 0 Тогда
		Параметры.Вставить("ac:type", "single");
		КолКолонок = 1;
	ИначеЕсли Тип = 1 Тогда
		Параметры.Вставить("ac:type", "two_equal"); 
		КолКолонок = 2;
	ИначеЕсли Тип = 2 Тогда
		Параметры.Вставить("ac:type", "two_left_sidebar"); 
		КолКолонок = 2;
	ИначеЕсли Тип = 3 Тогда
		Параметры.Вставить("ac:type", "two_right_sidebar"); 
		КолКолонок = 2;
	ИначеЕсли Тип = 4 Тогда
		Параметры.Вставить("ac:type", "three_equal"); 
		КолКолонок = 3;
	ИначеЕсли Тип = 5 Тогда
		Параметры.Вставить("ac:type", "three_with_sidebars"); 
		КолКолонок = 3;
	ИначеЕсли Тип = 6 Тогда
		Параметры.Вставить("ac:type", "fixed-width"); 
		КолКолонок = 1;
	Иначе 
		ВызватьИсключение НСтр("ru='Не верно передан тип блока'");
	КонецЕсли;
	
	Элементы = Новый Массив;
	Для Индекс = 1 По КолКолонок Цикл
		СтруктураЭлементы = Новый Структура;
		СтруктураЭлементы.Вставить("ТегHTML"	, "ac:layout-cell");
		СтруктураЭлементы.Вставить("Элементы"	, Новый Массив);
		
		Элементы.Добавить(СтруктураЭлементы);
	КонецЦикла;
	
	Возврат СтруктураЭлементаСтатьи("ac:layout-section", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки таблицы
//
// Параметры:
//	ТаблицаЗначений 	- ТаблицаЗначений, Массив
//	ВыводитьЗаголовок	- Булево
//	Заголовки			- Структура - имена колонок
//		Ключ		- Строка - имя колонки
//		Значение	- Строка - представление колонки
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - table
// 
Функция ЭлементТаблица(знач Коллекция, знач ВыводитьЗаголовок = Истина, знач Заголовки = Неопределено) Экспорт
	Если НЕ ТипЗнч(Заголовки) = Тип("Структура") Тогда
		Заголовки = Новый Структура;
	КонецЕсли;
	
	ЭтоТЗ		= (ТипЗнч(Коллекция) = Тип("ТаблицаЗначений"));
	ЭтоМассив	= (НЕ ЭтоТЗ И ТипЗнч(Коллекция) = Тип("Массив"));
	
	МассивКолонки = Новый Массив;
	Если ЭтоТЗ Тогда
		Для Каждого Колонка Из Коллекция.Колонки Цикл
			МассивКолонки.Добавить(Колонка.Имя);
		КонецЦикла;
	ИначеЕсли ЭтоМассив И Коллекция.Количество() > 0 Тогда
		Для Каждого КлючИЗначение Из Коллекция[0] Цикл
			МассивКолонки.Добавить(КлючИЗначение.Ключ);
		КонецЦикла;
	КонецЕсли;
		
	#Если Сервер Тогда
		Если ЭтоТЗ И Заголовки.Количество() = 0 Тогда
			Для Каждого Колонка Из Коллекция.Колонки Цикл
				СтрЗаголовок = ?(ПустаяСтрока(Колонка.Заголовок), Колонка.Имя, Колонка.Заголовок);
				Заголовки.Вставить(Колонка.Имя, СтрЗаголовок);
			КонецЦикла;
		КонецЕсли;
	#КонецЕсли
	
	СтруктураТело = СтруктураЭлементаСтатьи("tbody");
	
	Если ВыводитьЗаголовок Тогда
		ЭлементСтрока = СтруктураЭлементаСтатьи("tr");
		Для Индекс = 0 По МассивКолонки.ВГраница() Цикл
			ИмяКолонки			= МассивКолонки[Индекс];
			ЗаголовокКолонки	= ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Заголовки, ИмяКолонки, ИмяКолонки);
			
			ЭлементСтрока.Элементы.Добавить(СтруктураЭлементаСтатьи("th",, ЗаголовокКолонки));
		КонецЦикла;
		СтруктураТело.Элементы.Добавить(ЭлементСтрока);
	КонецЕсли;
	
	Для Каждого ОбъектДанных Из Коллекция Цикл
		ЭлементСтрока = СтруктураЭлементаСтатьи("tr");
		Для Индекс = 0 По МассивКолонки.ВГраница() Цикл
			ИмяКолонки		= МассивКолонки[Индекс];
			ЗначениеКолонки	= ОбъектДанных[ИмяКолонки];
			
			Если ТипЗнч(ЗначениеКолонки) = Тип("Массив") Тогда
				МассивЭлементов = ЗначениеКолонки;
			Иначе 
				МассивЭлементов = Новый Массив;
				МассивЭлементов.Добавить(ЗначениеКолонки);
			КонецЕсли;
				
			ЭлементСтрока.Элементы.Добавить(СтруктураЭлементаСтатьи("td",,, МассивЭлементов));
		КонецЦикла;
		СтруктураТело.Элементы.Добавить(ЭлементСтрока);
	КонецЦикла;
	
	СтруктураТаблица = СтруктураЭлементаСтатьи("table");
	СтруктураТаблица.Элементы.Добавить(СтруктураТело);
	
	Возврат СтруктураТаблица; 
КонецФункции

// Возвращает структуру для вставки ссылки на статью базы знаний
//
// Пример использования:
//	СсылкаНаСтатью = ЭлементСсылкаНаСтатью(НСтр("ru='Статья в базе знаний'"), НСтр("ru='Ссылка'")); 
//	Блок1.Элементы[0].Элементы.Добавить(СсылкаНаСтатью);
//
// HTML:
//	<ac:link>
//		<ri:page ri:content-title="{ЗаголовокСтатьи}"/>
//		<ac:plain-text-link-body>
//			<![CDATA[{Представление}]]>
//		</ac:plain-text-link-body>
//	</ac:link>
//
// Параметры:
//	ЗаголовокСтатьи - Строка - не указывается, если ссылка на закладку внутри текущей страницы
//	ИмяЗакладки		- Строка - не указывается, если нет необходимости переходить к закладке
//	Представление	- Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - ac:link
// 
Функция ЭлементСсылкаНаСтатью(знач Заголовок, знач ИмяЗакладки = "", знач Представление = "", знач Пространство = "") Экспорт
	Параметры1 = Новый Соответствие;
	Параметры1.Вставить("ri:content-title", Заголовок);
	Если НЕ ПустаяСтрока(Пространство) Тогда
		Параметры1.Вставить("ri:space-key", Пространство);
	КонецЕсли;
	
	СтруктураСсылка	= СтруктураЭлементаСтатьи("ri:page", Параметры1);
	СтруктураТекст	= СтруктураЭлементаСтатьи("ac:plain-text-link-body",, "<![CDATA[" + Представление + "]]>");
	
	Элементы = Новый Массив;
	Элементы.Добавить(СтруктураСсылка);
	
	Если НЕ ПустаяСтрока(Представление) Тогда
		Элементы.Добавить(СтруктураТекст);
	КонецЕсли;
	
	
	Параметры = Новый Соответствие;
	Если НЕ ПустаяСтрока(ИмяЗакладки) Тогда
		Параметры.Вставить("ac:anchor", ИмяЗакладки);
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи("ac:link", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки ссылки на статью базы знаний
//
// Пример использования:
//	СсылкаНаСтатью = ЭлементСсылкаНаСтатью(НСтр("ru='Статья в базе знаний'"), НСтр("ru='Ссылка'")); 
//	Блок1.Элементы[0].Элементы.Добавить(СсылкаНаСтатью);
//
// HTML:
//	<ac:link>
//		<ri:page ri:content-title="{ЗаголовокСтатьи}"/>
//		<ac:plain-text-link-body>
//			<![CDATA[{Представление}]]>
//		</ac:plain-text-link-body>
//	</ac:link>
//
// Параметры:
//	ЗаголовокСтатьи - Строка - не указывается, если ссылка на закладку внутри текущей страницы
//	ИмяЗакладки		- Строка - не указывается, если нет необходимости переходить к закладке
//	Представление	- Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - ac:link
// 
Функция ЭлементСсылкаНаЗаписьБлога(знач Заголовок, знач ДатаЗаписи, знач ИмяЗакладки = "", знач Представление = "", знач Пространство = "") Экспорт
	Параметры1 = Новый Соответствие;
	Параметры1.Вставить("ri:content-title"	, Заголовок);
	Параметры1.Вставить("ri:posting-day"	, Формат(ДатаЗаписи, "ДФ=yyyy/MM/dd"));
	Если НЕ ПустаяСтрока(Пространство) Тогда
		Параметры1.Вставить("ri:space-key", Пространство);
	КонецЕсли;
	
	СтруктураСсылка	= СтруктураЭлементаСтатьи("ri:blog-post", Параметры1);
	СтруктураТекст	= СтруктураЭлементаСтатьи("ac:plain-text-link-body",, "<![CDATA[" + Представление + "]]>");
	
	Элементы = Новый Массив;
	Элементы.Добавить(СтруктураСсылка);
	
	Если НЕ ПустаяСтрока(Представление) Тогда
		Элементы.Добавить(СтруктураТекст);
	КонецЕсли;
	
	Параметры = Новый Соответствие;
	Если НЕ ПустаяСтрока(ИмяЗакладки) Тогда
		Параметры.Вставить("ac:anchor", ИмяЗакладки);
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи("ac:link", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки ссылки на вложение статьи базы знаний
//
// Пример использования:
//	СсылкаНаФайл = ЭлементСсылкаНаВложение(НСтр("ru='Файл.txt'"), НСтр("ru='Текстовый файл'")); 
//	Блок1.Элементы[0].Элементы.Добавить(СсылкаНаФайл);
//
// HTML:
//	<ac:link>
//		<ri:attachment ri:filename="{ИмяВложения}" />
//		<ac:plain-text-link-body>
//			<![CDATA[{Представление}]]>
//		</ac:plain-text-link-body>
//	</ac:link>
//
// Параметры:
//	ИмяВложения		 - Строка
//	Представление	- Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - ac:link
// 
Функция ЭлементСсылкаНаВложение(знач ИмяВложения, знач Представление = "") Экспорт
	Параметры1 = Новый Соответствие;
	Параметры1.Вставить("ri:filename", ИмяВложения);
	
	СтруктураСсылка	= СтруктураЭлементаСтатьи("ri:attachment", Параметры1);
	СтруктураТекст	= СтруктураЭлементаСтатьи("ac:plain-text-link-body",, "<![CDATA[" + Представление + "]]>");
	
	Элементы = Новый Массив;
	Элементы.Добавить(СтруктураСсылка);
	Элементы.Добавить(СтруктураТекст);
	
	Возврат СтруктураЭлементаСтатьи("ac:link",,, Элементы);
КонецФункции

// Возвращает структуру для вставки ссылки на внешний ресурс
//
// Пример использования:
//	СсылкаНаГуголь = ЭлементСсылкаНаСтатью("https://www.google.com", НСтр("ru='Гуголь'")); 
//	Блок1.Элементы[0].Элементы.Добавить(СсылкаНаГуголь);
//
// HTML:
//	<a href="{АдресСсылки}">
//		{Представление}
//	</a>
//
// Параметры:
//	ИмяВложения		 - Строка
//	Представление	- Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - a
// 
Функция ЭлементСсылкаВнешняя(знач АдресСсылки, знач Представление = "") Экспорт
	Параметры = Новый Соответствие;
	Параметры.Вставить("href", АдресСсылки);
	
	Возврат СтруктураЭлементаСтатьи("a", Параметры, Представление);
КонецФункции

// Возвращает структуру для вставки заголовка
//
// Пример использования:
//	СсылкаНаСтатью = ЭлементСсылкаНаСтатью(НСтр("ru='Статья в базе знаний'"), НСтр("ru='Ссылка'")); 
//	Блок1.Элементы[0].Элементы.Добавить(СсылкаНаСтатью);
//
// Параметры:
//	Уровень	- Число - значения от 1 до 6
//	Текст	- Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - hN, где N - уровень заголовка
// 
Функция ЭлементЗаголовок(знач Уровень = 1, знач Текст) Экспорт 
	Если НЕ ТипЗнч(Уровень) = Тип("Число") Тогда
		Уровень = 1;
	КонецЕсли;
	
	Если Уровень < 1 Тогда
		Уровень = 1;
	ИначеЕсли Уровень > 6 Тогда
		Уровень = 6;
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи("h" + Формат(Уровень, "ЧН=0; ЧГ="),, Текст);
КонецФункции

// Возвращает структуру для вставки маркированного или нумерованного
// списка.
//
// Параметры:
//	ВидСписка - Число
//		0 - маркированный
//		1 - нумерованный
//
// Возвращаемое значение:
//   Структура
//		ТегHTML		- Строка - ul, ol
// 
Функция ЭлементСписок(знач ВидСписка, знач Элементы = Неопределено) Экспорт 
	Если НЕ ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	Если ВидСписка = 0 Тогда
		ТегHTML = "ul";
	ИначеЕсли ВидСписка = 1 Тогда
		ТегHTML = "ol";
	Иначе 
		ВызватьИсключение НСтр("ru='Некорректно указан вид списка.'");
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи(ТегHTML,,, Элементы);
КонецФункции

// Возвращает структуру элемента маркированного или нумерованного списка.
//
// Параметры:
//	Текст		- Строка, ФорматированнаяСтрока - произвольный текст для добавления автоматически
//	Элементы	- Массив - массив вложенных объектов, обязательный реквизит
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - li
// 
Функция ЭлементЗначениеСписка(знач Текст = "", знач Элементы = Неопределено) Экспорт 
	Если НЕ ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Текст) Тогда
		Элементы.Вставить(0, ЭлементТекст(Текст, Ложь));
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи("li",,, Элементы);
КонецФункции

// Возвращает структуру элемента маркированного или нумерованного списка.
//
// Параметры:
//	ИмяВложения	- Строка - имя файла вложения или адрес картинки в интернете
//	Настройки	- Структура
//		Выравнивание	- Строка - Центр, Лево, Право
//		Граница			- Булево - Истина - выводить границу
//		Подсказка		- Строка - текст подсказки
//		Высота			- Число
//		Ширина			- Число
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - ac:image
// 
Функция ЭлементКартинка(знач ИмяВложения, знач Настройки = Неопределено) Экспорт
	Если НЕ ТипЗнч(Настройки) = Тип("Структура") Тогда
		Настройки = Новый Структура;
	КонецЕсли;
	
	Если СтрНачинаетсяС(ИмяВложения, "http://") ИЛИ СтрНачинаетсяС(ИмяВложения, "https://") Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ri:value", ИмяВложения);
		
		СтруктураВложение = СтруктураЭлементаСтатьи("ri:url", Параметры1);
	Иначе 
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ri:filename", ИмяВложения);
	
		СтруктураВложение = СтруктураЭлементаСтатьи("ri:attachment", Параметры1);
	КонецЕсли;
	
	Элементы = Новый Массив;
	Элементы.Добавить(СтруктураВложение);
	
	Параметры = Новый Соответствие;
	Если Настройки.Свойство("Выравнивание") Тогда
		Значение = "";
		Если НРег(Настройки.Выравнивание) = "центр" Тогда
			Значение = "center";
		ИначеЕсли НРег(Настройки.Выравнивание) = "лево" Тогда
			Значение = "left";
		ИначеЕсли НРег(Настройки.Выравнивание) = "право" Тогда
			Значение = "right";
		КонецЕсли;
		
		Параметры.Вставить("ac:align", Значение);
	КонецЕсли;
	Если Настройки.Свойство("Граница") И Настройки.Граница = Истина Тогда
		Параметры.Вставить("ac:border", "true");
	КонецЕсли;
	Если Настройки.Свойство("Подсказка") Тогда
		Параметры.Вставить("ac:title", Настройки.Подсказка);
	КонецЕсли;
	Если Настройки.Свойство("Высота") Тогда
		Параметры.Вставить("ac:height", Настройки.Высота);
	КонецЕсли;
	Если Настройки.Свойство("Ширина") Тогда
		Параметры.Вставить("ac:width", Настройки.Ширина);
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи("ac:image", Параметры,, Элементы);
КонецФункции

// Возвращает структуру элемента цитаты.
//
// Параметры:
//	Текст		- Строка, ФорматированнаяСтрока - произвольный текст для добавления автоматически
//	Элементы	- Массив - массив вложенных объектов, обязательный реквизит
//
// Возвращаемое значение:
//   Структура
//		ТегHTML - blockquote
// 
Функция ЭлементЦитата(знач Текст = "", знач Элементы = Неопределено) Экспорт
	Если НЕ ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	Если ЗначениеЗаполнено(Текст) Тогда
		Элементы.Вставить(0, ЭлементТекст(Текст, Ложь));
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи("blockquote",,, Элементы);
КонецФункции

// Возвращает структуру для вставки произвольного текста HTML
// Текст может содержать так же элементы хранилища Confluence
// Подробнее см. Confluence Storage Format
//
// HTML:
//	<p>
//		{СтрокаHTML}
//	</p>
//
// Параметры:
//	СтрокаHTML - Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- p
// 
Функция ЭлементHTML(знач СтрокаHTML) Экспорт
	Возврат СтруктураЭлементаСтатьи("p",, ПодготовитьТекстHTMLДляВставки(СтрокаHTML));
КонецФункции

// Возвращает структуру для вставки произвольного текста.
// Перед установкой текст будет преобразован в строку HTML,
// таким образом все спец. символы будут преобразованы в код HTML
//
// HTML:
//	<p> или <span>
//		{СтрокаТекст}
//	</p> или </span>
//
// Параметры:
//	ПараметрСтрока	- Строка, ФорматированнаяСтрока
//	ПереносСтроки	- Булево
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- p, span
// 
Функция ЭлементТекст(знач ПараметрСтрока = "", ПереносСтроки = Истина) Экспорт
	ЗначСтрока = ПодготовитьТекстДляВставки(ПараметрСтрока);
	
	Если НЕ ПереносСтроки = Истина Тогда
		ТегHTML = "span";
	Иначе 
		ТегHTML = "p";
	КонецЕсли;
	
	Возврат СтруктураЭлементаСтатьи(ТегHTML,, ЗначСтрока);
КонецФункции

// Возвращает структуру для вставки пиктограммы
//
// HTML:
//	<ac:emoticon ac:name="smile" />
//
// Параметры:
//	Пиктограмма - Число, Строка - можно передать номер или имя пиктограммы
//		1 - smile, 2 - sad, 3 - cheeky, 4 - laugh, 5 - wink, 6 - thumbs-up, 
//		7 - thumbs-down, 8 - information, 9 - tick, 10 - cross, 11 - warning, 
//		12 - plus, 13 - minus, 14 - question, 15 - light-on,  16 - light-off, 
//		17 - yellow-star, 18 - red-star, 19 - green-star, 20 - blue-star
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- p
// 
Функция ЭлементПиктограмма(знач Пиктограмма) Экспорт
	Массив = СтрРазделить("smile,sad,cheeky,laugh,wink,thumbs-up,thumbs-down,"
		+ "information,tick,cross,warning,plus,minus,question,light-on,"
		+ "light-off,yellow-star,red-star,green-star,blue-star", ",");
	
	ИмяПиктограммы = "";
	Если ТипЗнч(Пиктограмма) = Тип("Число") Тогда
		Если Пиктограмма > 0 И Пиктограмма <= Массив.Количество() Тогда
			ИмяПиктограммы = Массив[Пиктограмма - 1];
		КонецЕсли;
	ИначеЕсли ТипЗнч(Пиктограмма) = Тип("Строка") Тогда 
		ИмяПиктограммы = Пиктограмма;
	КонецЕсли;
	
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", ИмяПиктограммы);
	
	Возврат СтруктураЭлементаСтатьи("ac:emoticon", Параметры);
КонецФункции

// Возвращает структуру для вставки блока с описанием.
// Содержание данного блока выводится в реквизит "Описание" в вышестоящие страницы,
// при поиске и т.д.
// Подробно см. https://confluence.atlassian.com/doc/excerpt-macro-148062.html
//
// HTML:
//	<ac:structured-macro ac:name="excerpt">
//		<ac:parameter ac:name="hidden">true</ac:parameter>
//		<ac:parameter ac:name="atlassian-macro-output-type">BLOCK</ac:parameter>
//		<ac:rich-text-body>
//			<p>This is the <strong>text</strong> I want to reuse in other pages. This text is inside an Excerpt macro.</p>
//		</ac:rich-text-body>
//	</ac:structured-macro>
//
// Параметры:
//	Элементы	- Массив - массив вложенных объектов, обязательный реквизит
//	Скрыть		- Булево - не выводить блок на экран (будет только для описания)
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросОписание(знач Элементы, знач Скрыть = Истина) Экспорт
	Элементы1 = Новый Массив;
	
	Если Скрыть = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "hidden");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	#Область ВыводКакБлок
	Параметры1 = Новый Соответствие;
	Параметры1.Вставить("ac:name", "atlassian-macro-output-type");
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "BLOCK");
	Элементы1.Добавить(СтруктураПараметр);
	#КонецОбласти 
	
	СтруктураТекст = СтруктураЭлементаСтатьи("ac:rich-text-body",,, Элементы);
	Элементы1.Добавить(СтруктураТекст);
	
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "excerpt");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

// Возвращает структуру для вставки закладки на текущей странице
// Подробно см. https://confluence.atlassian.com/doc/anchor-macro-182682072.html
//
// HTML:
//	<ac:structured-macro ac:name="anchor">
//		<ac:parameter ac:name="">{ИмяЗакладки}</ac:parameter>
//	</ac:structured-macro>
//
// Параметры:
//	ИмяЗакладки - Строка
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросЗакладка(знач ИмяЗакладки) Экспорт
	Параметры1 = Новый Соответствие;
	Параметры1.Вставить("ac:name", "");
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ИмяЗакладки);
	
	Элементы = Новый Массив;
	Элементы.Добавить(СтруктураПараметр);
	
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "anchor");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки оглавления по подчиненным страницам
// Подробно см. https://confluence.atlassian.com/doc/children-display-macro-139501.html
//
// HTML:
//	<ac:structured-macro ac:name="children">
//		<ac:parameter ac:name="all">true</ac:parameter>
//		<ac:parameter ac:name="depth">2</ac:parameter>
//		<ac:parameter ac:name="page">
//			<ac:link>
//				<ri:page ri:content-title="Rest API Confluence"/>
//			</ac:link>
//		</ac:parameter>
//		<ac:parameter ac:name="reverse">true</ac:parameter>
//		<ac:parameter ac:name="sort">title</ac:parameter>
//		<ac:parameter ac:name="excerptType">simple</ac:parameter>
//		<ac:parameter ac:name="first">5</ac:parameter>
//	</ac:structured-macro>
//
// Параметры:
//	Подчиненные 	- Булево - если Истина, можно указать уровень вывода подчиненных страниц (см. Уровень)
//	Уровень			- Число
//	Родитель		- Строка - страница, от которой необходимо построить оглавление
//		"/" - не подчиненные страницы
//		"{Заголовок}" - заголовок родительской страницы
//		"{КлючПространства}:" - ключ пространства
//		"{КлючПространства}:{Заголовок}" - имя родительской страницы в пространстве
//	Подробно		- Булево - отображать краткое содержание статьи
//	Сортировка		- Строка - предопреленные значения: ДатаСоздания, Заголовок, ДатаИзменения
//	ОбратныйПорядок	- Булево
//	
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросПодчиненныеСтатьи(знач Подчиненные = Ложь,
	знач Уровень = 0,
	знач Родитель = "",
	знач Количество = 0,
	знач Подробно = Ложь,
	знач Сортировка = "",
	знач ОбратныйПорядок = Ложь) Экспорт
	
	Элементы = Новый Массив;
	Если Подчиненные = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "all");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Подчиненные И Уровень > 0 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "depth");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(Уровень, "ЧН=0; ЧГ="));
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(Родитель) Тогда
		Параметры2 = Новый Соответствие;
		Параметры2.Вставить("ri:content-title", Родитель);
		
		Элементы2 = Новый Массив;
		Элементы2.Добавить(СтруктураЭлементаСтатьи("ri:page", Параметры2));
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "page");
		
		Элементы1 = Новый Массив;
		Элементы1.Добавить(СтруктураЭлементаСтатьи("ac:link",,, Элементы2));
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1,, Элементы1);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Количество > 0 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "first");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(Количество, "ЧН=0; ЧГ="));
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Подробно = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "excerptType");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "simple");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(Сортировка) Тогда
		Если НРег(Сортировка) = "датасоздания" Тогда
			ПолеСортировки = "creation";
		ИначеЕсли НРег(Сортировка) = "заголовок" Тогда
			ПолеСортировки = "title";
		ИначеЕсли НРег(Сортировка) = "датаизменения" Тогда
			ПолеСортировки = "modified";
		Иначе 
			ПолеСортировки = "";
		КонецЕсли;
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "sort");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ПолеСортировки);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ОбратныйПорядок = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "reverse");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "children");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки блока с кодом
// Подробно см. https://confluence.atlassian.com/doc/code-block-macro-139390.html
//
// HTML:
//	<ac:structured-macro ac:name="code">
//		<ac:parameter ac:name="title">This is my title</ac:parameter>
//		<ac:parameter ac:name="theme">FadeToGrey</ac:parameter>
//		<ac:parameter ac:name="linenumbers">true</ac:parameter>
//		<ac:parameter ac:name="language">xml</ac:parameter>
//		<ac:parameter ac:name="firstline">0001</ac:parameter>
//		<ac:parameter ac:name="collapse">true</ac:parameter>
//		<ac:plain-text-body><![CDATA[{Код}]]></ac:plain-text-body>
//	</ac:structured-macro>//
//
// Параметры:
//	Код				- Строка
//	Заголовок		- Строка
//	Нумерация		- Булево - выводить номера строк
//	Сворачивать		- Булево - добавить возможность сворачивать блок с кодом
//	Язык			- Строка
//		actionscript3, bash, csharp (C#), coldfusion, cpp (C++), css, delphi,
//		diff, erlang, groovy, html/xml, java, javafx, javascript,
//		none (no syntax highlighting), perl, php, powershell, python, ruby,
//		scala, sql, vb
//	НачалоНумерации	- Число
//	Тема			- Строка
//		DJango, Emacs, FadeToGrey, Midnight, RDark, Eclipse, Confluence
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросКод(знач Код, 
	знач Заголовок = "",
	знач Нумерация = Ложь,
	знач Сворачивать = Ложь,
	знач Язык = "",
	знач НачалоНумерации = 1,
	знач Тема = "") Экспорт
	
	Элементы = Новый Массив;
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "title");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Заголовок);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Нумерация = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "linenumbers");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Сворачивать = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "collapse");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(Язык) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "language");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Язык);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НачалоНумерации <> 1 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "firstline");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(НачалоНумерации, "ЧН=0; ЧГ="));
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(Тема) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "theme");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Тема);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:plain-text-body",, "<![CDATA[" + Код + "]]>");
	Элементы.Добавить(СтруктураПараметр);
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "code");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки блока для сверки содержимого
// Подробно см. https://confluence.atlassian.com/doc/expand-macro-223222352.html
//
// HTML:
//	<ac:structured-macro ac:name="expand">
//		<ac:parameter ac:name="title">Expand me...</ac:parameter>
//		<ac:rich-text-body>
//			{content}
//		</ac:rich-text-body>
//	</ac:structured-macro>
//
// Параметры:
//	Заголовок	- Строка
//	Элементы	- Массив - массив вложенных объектов, обязательный реквизит
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросСворачивание(знач Заголовок = "", знач Элементы) Экспорт
	Если НЕ ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	Элементы1 = Новый Массив;
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "title");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Заголовок);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:rich-text-body",,, Элементы);
	Элементы1.Добавить(СтруктураПараметр);
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "expand");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

// Возвращает структуру для вставки блока информациии, подсказки, предупреждения, примечания
// Подробно см. https://confluence.atlassian.com/doc/info-tip-note-and-warning-macros-51872369.html
//
// HTML:
//	<ac:structured-macro ac:name="info">
//		<ac:parameter ac:name="icon">false</ac:parameter>
//		<ac:parameter ac:name="title">This is my title</ac:parameter>
//		<ac:rich-text-body>
//			{content}
//		</ac:rich-text-body>
//	</ac:structured-macro>
//
// Параметры:
//	Вид			- Число
//		0 - Информация
//		1 - Подсказка
//		2 - Примечание
//		3 - Предупреждение
//	Заголовок	- Строка
//	Элементы	- Массив - массив вложенных объектов, обязательный реквизит
//	Пиктограмма	- Булево - выводить пиктограмму
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросИнформационныйБлок(знач Вид = 0, знач Заголовок = "", знач Элементы, знач Пиктограмма = Истина) Экспорт
	Если Вид = 1 Тогда
		ИмяБлока = "tip";
	ИначеЕсли Вид = 2 Тогда
		ИмяБлока = "note";
	ИначеЕсли Вид = 3 Тогда
		ИмяБлока = "warning";
	Иначе 
		ИмяБлока = "info";
	КонецЕсли;
	
	Если НЕ ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	Элементы1 = Новый Массив;
	Если Пиктограмма = Ложь Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "icon");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "false");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "title");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Заголовок);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:rich-text-body",,, Элементы);
	Элементы1.Добавить(СтруктураПараметр);
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", ИмяБлока);
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

// Возвращает структуру для вставки дерева подчиненных страниц
// Подробно см. https://confluence.atlassian.com/doc/page-tree-macro-163414255.html
//
// HTML:
//	<ac:structured-macro ac:name="pagetree">
//		<ac:parameter ac:name="reverse">false</ac:parameter>
//		<ac:parameter ac:name="sort">natural</ac:parameter>
//		<ac:parameter ac:name="root">
//			<ac:link>
//				<ri:page ri:content-title="Page Name"/>
//			</ac:link>
//		</ac:parameter>
//		<ac:parameter ac:name="startDepth">3</ac:parameter>
//		<ac:parameter ac:name="excerpt">true</ac:parameter>
//		<ac:parameter ac:name="searchBox">true</ac:parameter>
//		<ac:parameter ac:name="expandCollapseAll">true</ac:parameter>
//	</ac:structured-macro>
//
// Параметры:
//	Родитель		- Строка - заголовок статьи или спец. строка, от которой будет построено дерево
//		@home	- все страницы пространства после главной
//		@self	- все страницы под текущей
//		@parent	- все страницы под родительской, вкл. текущую
//		@none	- все страницы пространства, вкл. не подчиненные и главную
//	Глубина			- Число - глубина вывода страниц, если 0 - выводить все
//	Подробно		- Булево - выводить краткое содержание страниц
//	Сортировка		- Строка - способ сортировки страниц
//		ДатаСоздания - по дате создания страницы
//		ДатаИзменения - по дате изменения страницы
//		Заголовок - по заголовку страницы
//		Позиция - по позиции установленной пользователем или заголовку
//	ОбратныйПорядок	- Булево - сортировка в обратном порядке
//	Сворачивать		- Булево - добавлять кнопку сворачивания дерева
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросДеревоСтраниц(знач Родитель = "", 
	знач Глубина = 0,
	знач Подробно = Ложь,
	знач Сортировка = "",
	знач ОбратныйПорядок = Ложь,
	знач ПолеПоиска = Ложь,
	знач Сворачивать = Ложь) Экспорт
	
	Элементы = Новый Массив;
	Если НЕ ПустаяСтрока(Родитель) Тогда
		Параметры2 = Новый Соответствие;
		Параметры2.Вставить("ri:content-title", Родитель);
		
		СтруктураСтраница = СтруктураЭлементаСтатьи("ri:page", Параметры2);
		
		Элементы2 = Новый Массив;
		Элементы2.Добавить(СтруктураСтраница);
		
		Элементы1 = Новый Массив;
		Элементы1.Добавить(СтруктураЭлементаСтатьи("ac:link",,, Элементы1));
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "root");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1,, Элементы1);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Глубина <> 0 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "startDepth");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(Глубина, "ЧН=0; ЧГ="));
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Подробно = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "excerpt");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(Сортировка) Тогда
		Если НРег(Сортировка) = "датасоздания" Тогда
			ПолеСортировки = "creation";
		ИначеЕсли НРег(Сортировка) = "датаизменения" Тогда
			ПолеСортировки = "modified";
		ИначеЕсли НРег(Сортировка) = "заголовок" Тогда
			ПолеСортировки = "natural";
		ИначеЕсли НРег(Сортировка) = "позиция" Тогда
			ПолеСортировки = "position";
		Иначе 
			ПолеСортировки = "";
		КонецЕсли;
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "sort");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ПолеСортировки);
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ОбратныйПорядок = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "reverse");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ПолеПоиска = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "searchBox");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Сворачивать = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "expandCollapseAll");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы.Добавить(СтруктураПараметр);
	КонецЕсли;
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "pagetree");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы);
КонецФункции

// Возвращает структуру для вставки неформатированного блока
// Подробно см. https://confluence.atlassian.com/doc/page-tree-macro-163414255.html
//
// HTML:
//	<ac:structured-macro ac:name="noformat">
//		<ac:parameter ac:name="nopanel">true</ac:parameter>
//		<ac:plain-text-body><![CDATA[http://www.example.com]]></ac:plain-text-body>
//	</ac:structured-macro>
//
// Параметры:
//	Рамка		- Булево - выводить или нет рамку вокруг
//	Элементы	- Массив - массив вложенных объектов, обязательный реквизит
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросНеформатированныйБлок(знач Рамка = Истина, знач Элементы) Экспорт
	Элементы1 = Новый Массив;
	Если Рамка = Ложь Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "nopanel");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:plain-text-body",,, Элементы);
	Элементы1.Добавить(СтруктураПараметр);
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "noformat");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

// Возвращает структуру для вставки форматированного блока
// Подробно см. https://confluence.atlassian.com/doc/page-tree-macro-163414255.html
//
// HTML:
//	<ac:structured-macro ac:name="panel">
//		<ac:parameter ac:name="bgColor">#72bc72</ac:parameter>
//		<ac:parameter ac:name="titleBGColor">#00a400</ac:parameter>
//		<ac:parameter ac:name="title">My title</ac:parameter>
//		<ac:parameter ac:name="borderStyle">dashed</ac:parameter>
//		<ac:parameter ac:name="borderColor">blue</ac:parameter>
//		<ac:parameter ac:name="titleColor">white</ac:parameter>
//		<ac:rich-text-body>
//			{content}
//		</ac:rich-text-body>
//	</ac:structured-macro>
//
// Параметры:
//	Заголовок			- Строка - текст заголовка
//	СтильРамки			- Строка - solid (сплошная), dashed (прерывистая) или любое другое
//								   значение стиля из CSS нотации
//	ЦветРамки			- Цвет, Строка - цвет или hex значение цвета
//	ТолщинаРамки		- Число - толщина рамки в пикселях
//	ЦветФона			- Цвет, Строка - цвет или hex значение цвета
//	ЦветФонаЗаголовка	- Цвет, Строка - цвет или hex значение цвета
//	ЦветТекстаЗаголовка	- Цвет, Строка - цвет или hex значение цвета
//	Элементы			- Массив - массив вложенных объектов, обязательный реквизит
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросФорматированныйБлок(знач Заголовок = "",
	знач СтильРамки = "",
	знач ЦветРамки = "",
	знач ТолщинаРамки = 1,
	знач ЦветФона = "",
	знач ЦветФонаЗаголовка = "",
	знач ЦветТекстаЗаголовка = "",
	знач Элементы) Экспорт
	
	Элементы1 = Новый Массив;
	Если НЕ ПустаяСтрока(Заголовок) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "title");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Заголовок);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(СтильРамки) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "borderStyle");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, СтильРамки);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЦветРамки) Тогда
		Если ТипЗнч(ЦветРамки) = Тип("Цвет") Тогда
			ЦветHEX = ОбщегоНазначенияПТБКлиентСервер.ЦветВHex(ЦветРамки.Красный, ЦветРамки.Зеленый, ЦветРамки.Синий);
		Иначе 
			ЦветHEX = ЦветРамки;
		КонецЕсли;
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "borderColor");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ЦветHEX);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ТолщинаРамки <> 1 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "borderWidth");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(ТолщинаРамки, "ЧН=0; ЧГ="));
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЦветФона) Тогда
		Если ТипЗнч(ЦветФона) = Тип("Цвет") Тогда
			ЦветHEX = ОбщегоНазначенияПТБКлиентСервер.ЦветВHex(ЦветФона.Красный, ЦветФона.Зеленый, ЦветФона.Синий);
		Иначе 
			ЦветHEX = ЦветФона;
		КонецЕсли;
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "bgColor");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ЦветHEX);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЦветФонаЗаголовка) Тогда
		Если ТипЗнч(ЦветФонаЗаголовка) = Тип("Цвет") Тогда
			ЦветHEX = ОбщегоНазначенияПТБКлиентСервер.ЦветВHex(ЦветФонаЗаголовка.Красный, ЦветФонаЗаголовка.Зеленый, ЦветФонаЗаголовка.Синий);
		Иначе 
			ЦветHEX = ЦветФонаЗаголовка;
		КонецЕсли;
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "titleBGColor");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ЦветHEX);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ЗначениеЗаполнено(ЦветТекстаЗаголовка) Тогда
		Если ТипЗнч(ЦветТекстаЗаголовка) = Тип("Цвет") Тогда
			ЦветHEX = ОбщегоНазначенияПТБКлиентСервер.ЦветВHex(ЦветТекстаЗаголовка.Красный, ЦветТекстаЗаголовка.Зеленый, ЦветТекстаЗаголовка.Синий);
		Иначе 
			ЦветHEX = ЦветТекстаЗаголовка;
		КонецЕсли;
		
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "titleColor");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ЦветHEX);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:rich-text-body",,, Элементы);
	Элементы1.Добавить(СтруктураПараметр);
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "panel");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

// Возвращает структуру для вставки форматированного блока
// Подробно см. https://confluence.atlassian.com/doc/table-of-contents-macro-182682099.html
//
// HTML:
//	<ac:structured-macro ac:name="toc">
//		<ac:parameter ac:name="printable">true</ac:parameter>
//		<ac:parameter ac:name="style">square</ac:parameter>
//		<ac:parameter ac:name="maxLevel">2</ac:parameter>
//		<ac:parameter ac:name="indent">5px</ac:parameter>
//		<ac:parameter ac:name="minLevel">2</ac:parameter>
//		<ac:parameter ac:name="class">bigpink</ac:parameter>
//		<ac:parameter ac:name="exclude">[1//2]</ac:parameter>
//		<ac:parameter ac:name="type">list</ac:parameter>
//		<ac:parameter ac:name="outline">true</ac:parameter>
//		<ac:parameter ac:name="include">.*</ac:parameter>
//	</ac:structured-macro>
//
// Параметры:
//	Горизонтально				- Булево
//	Нумерация					- Булево
//	СтильМаркера				- Строка - любой CSS стиль для маркированного списка
//		Например: none, circle, disc, square, decimal, lower-alpha, lower-roman, upper-roman
//	ГоризонтальныйРазделитель	- Строка - символ разделитель при горизонтальном выводе содержания
//		Допустимые значения: brackets, braces, parens, pipe
//		Так же можно использовать собственный разделитель. При этом необходимо учитывать, чтобы разделитель
//		отображается как есть, без дополнительных разделов между заголовками. 
//	НачальныйУровень			- Число
//	КонечныйУровень				- Число
//	ИсключаемыеЗаголовки		- Строка - можно использовать регулярные выражения, см. Sun's Regex
//		Синтаксис: https://docs.oracle.com/javase/1.5.0/docs/api/java/util/regex/Pattern.html
//	ВыводитьНаПечать			- Булево
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросСодержание(знач Горизонтально = Ложь,
	знач Нумерация = Ложь,
	знач СтильМаркера = "",
	знач ГоризонтальныйРазделитель = "",
	знач НачальныйУровень = 1,
	знач КонечныйУровень = 7,
	знач ИсключаемыеЗаголовки = "",
	знач ВыводитьНаПечать = Ложь) Экспорт
	
	Элементы1 = Новый Массив;
	Если Горизонтально = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "type");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "flat");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Нумерация = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "outline");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если СтильМаркера = "" Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "style");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, СтильМаркера);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если Горизонтально = Истина И НЕ ПустаяСтрока(ГоризонтальныйРазделитель) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "separator");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ГоризонтальныйРазделитель);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НачальныйУровень > 1 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "minLevel");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(НачальныйУровень, "ЧН=0; ЧГ="));
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если КонечныйУровень < 7 Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "maxLevel");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Формат(КонечныйУровень, "ЧН=0; ЧГ="));
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если НЕ ПустаяСтрока(ИсключаемыеЗаголовки) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "exclude");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, ИсключаемыеЗаголовки);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	Если ВыводитьНаПечать = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "Printable");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "toc");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

// Возвращает структуру для вставки макроса статус
// Подробно см. https://confluence.atlassian.com/doc/status-macro-223222355.html
//
// HTML:
//	<ac:structured-macro ac:name="status">
//		<ac:parameter ac:name="colour">Green</ac:parameter>
//		<ac:parameter ac:name="title">On track</ac:parameter>
//		<ac:parameter ac:name="subtle">true</ac:parameter>
//	</ac:structured-macro>
//
// Параметры:
//	Цвет			- Число, Строка - номер или строковое представление цвета
//		1 - Grey, 2 - Red, 3 - Yellow, 4 - Green, 5 - Blue, 6 - Purple
//	Заголовок		- Строка
//	ТолькоКонтур	- Булево - выводить только контур
//
// Возвращаемое значение:
//   Структура
//		ТегHTML	- ac:structured-macro
// 
Функция МакросСтатус(знач Цвет = "Grey", знач Заголовок, знач ТолькоКонтур = Ложь) Экспорт
	Массив = СтрРазделить("Grey,Red,Yellow,Green,Blue,Purple", ",");
	
	Если ТипЗнч(Цвет) = Тип("Число") Тогда
		Если Цвет > 0 И Цвет <= Массив.Количество() Тогда
			СтрЦвет = Массив[Цвет - 1];
		КонецЕсли;
	ИначеЕсли ТипЗнч(Цвет) = Тип("Строка") Тогда
		СтрЦвет = Цвет;
	КонецЕсли;
	
	Элементы1 = Новый Массив;

	#Область Цвет
	Если ЗначениеЗаполнено(СтрЦвет) Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "colour");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, СтрЦвет);
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
	#КонецОбласти
	
	#Область Заголовок
	Параметры1 = Новый Соответствие;
	Параметры1.Вставить("ac:name", "title");
	
	СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, Заголовок);
	Элементы1.Добавить(СтруктураПараметр);
	#КонецОбласти 
	
	Если ТолькоКонтур = Истина Тогда
		Параметры1 = Новый Соответствие;
		Параметры1.Вставить("ac:name", "subtle");
		
		СтруктураПараметр = СтруктураЭлементаСтатьи("ac:parameter", Параметры1, "true");
		Элементы1.Добавить(СтруктураПараметр);
	КонецЕсли;
		
	Параметры = Новый Соответствие;
	Параметры.Вставить("ac:name", "status");
	
	Возврат СтруктураЭлементаСтатьи("ac:structured-macro", Параметры,, Элементы1);
КонецФункции

#КонецОбласти

#Область СлужебныйПрограммныйИнтерфейс

// Выполняет проверку структуры на принадлженость к ошибке. Возвращает признак,
// что переданная структура - это описание ошибки. При необходимости выводит
// сообщение пользователю с текстом ошибки
//
// Параметры:
//	Структура			- Структура
//	СообщениеИсключение	- Булево - если значение не булево, ничего не происходит
//		Истина	- выводить сообщение
//		Ложь	- вызвать исключение
//
// Возвращаемое значение:
//   Булево
// 
Функция ПроверитьОшибки(знач Структура, знач СообщениеИсключение = Неопределено) Экспорт 
	ТипСтруктуры = СвойствоСтруктуры(Структура, "type", "");
	
	ЭтоОшибка = (ТипСтруктуры = "error");
	Если НЕ ЭтоОшибка Тогда
		Возврат Ложь;
	КонецЕсли;
	
	ДопТекст = СокрЛП(Структура.ДопТекст);
	Если НЕ ПустаяСтрока(ДопТекст) Тогда
		Если НЕ СтрЗаканчиваетсяНа(ДопТекст, ".") Тогда
			ДопТекст = ДопТекст + ".";
		КонецЕсли;
		ДопТекст = ДопТекст + " ";
	КонецЕсли;
	
	ТекстОшибки = СтрШаблон(НСтр("ru='%1Код ошибки: %2 (%3)'"),
		ДопТекст,
		Строка(Структура.Код),
		СокрЛП(Структура.Текст));
		
	Если СообщениеИсключение = Истина Тогда
		ОбщегоНазначенияКлиентСервер.СообщитьПользователю(ТекстОшибки);
	ИначеЕсли СообщениеИсключение = Ложь Тогда
		ВызватьИсключение ТекстОшибки;
	КонецЕсли;
	
	Возврат Истина;
КонецФункции

// Формирует строку запроса для выполнения поиска по базе знаний
//
// Параметры:
//	НастройкаПоиска	- Структура - см. ИнтеграцияConfluenceКлиентСервер.НастройкаПоиска
//
// Возвращаемое значение:
//   Строка
// 
Функция ПолучитьСтрокуЗапросаПоиска(знач НастройкаПоиска) Экспорт
	Возврат СформироватьСтрокуПоискаПоНастройке(НастройкаПоиска);
КонецФункции

Функция ПолучитьСтрокуConfluenceStorage(знач СтруктураСтатьи) Экспорт
	СтрХранилище = "";
	Для Каждого ВложенныйЭлемент Из СтруктураСтатьи.Тело Цикл
		СтрХранилище = СтрХранилище + СформироватьHTMLЭлемента(ВложенныйЭлемент);
	КонецЦикла;
	Возврат СтрХранилище;
КонецФункции

Функция СформироватьHTMLЭлемента(знач Элемент) Экспорт
	ТипПараметра = ТипЗнч(Элемент);
	Если НЕ ТипПараметра = Тип("Структура") И НЕ ТипПараметра = Тип("ФиксированнаяСтруктура") Тогда
		Если НЕ ТипПараметра = Тип("Строка") Тогда
			Возврат ?(Элемент = Неопределено ИЛИ Элемент = NULL, "", Строка(Элемент));
		Иначе 
			Возврат Элемент;
		КонецЕсли;
	КонецЕсли;
	
	ИмяТега		= СвойствоСтруктуры(Элемент, "ТегHTML", "");
	Параметры	= СвойствоСтруктуры(Элемент, "Параметры", Новый Соответствие);
	ВнутрТекст	= СвойствоСтруктуры(Элемент, "Текст", "");
	Элементы	= СвойствоСтруктуры(Элемент, "Элементы", Новый Массив);
	
	Если НЕ ЗначениеЗаполнено(ИмяТега) Тогда
		Возврат ""; 
	КонецЕсли;  
	
	СтрПараметры	= СформироватьHTMLПараметры(Параметры);
	СтрЭлементы		= "";
	
	Для Каждого ВложенныйЭлемент Из Элементы Цикл
		СтрЭлемент = СформироватьHTMLЭлемента(ВложенныйЭлемент);
		Если ПустаяСтрока(СтрЭлемент) Тогда
			Продолжить;
		КонецЕсли;
		
		СтрЭлементы = СтрЭлементы + ?(ПустаяСтрока(СтрЭлементы), "", " ") + СтрЭлемент;
	КонецЦикла;
	
	ВнутрТекст = ВнутрТекст + СтрЭлементы;
	
	Если ПустаяСтрока(ВнутрТекст) Тогда
		СтрокаHTML = СтрШаблон("<%1%2/>", ИмяТега, СтрПараметры);
	Иначе 
		СтрокаHTML = СтрШаблон("<%1%2>%3</%1>", ИмяТега, СтрПараметры, ВнутрТекст);
	КонецЕсли;
	
	Возврат СтрокаHTML;
КонецФункции

#КонецОбласти
 
#Область СлужебныеПроцедурыИФункции_Поиск

Функция СформироватьСтрокуПоискаПоНастройке(знач Параметры)
	Если НЕ ТипЗнч(Параметры) = Тип("Структура") Тогда
		Возврат "";
	ИначеЕсли СвойствоСтруктуры(Параметры, "type", "") <> "searchdata" Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаПоиска = "";
	Для Каждого ЭлементПоиска Из Параметры.Элементы Цикл
		СтрокаПоискаПоля = СформироватьСтрокуПоискаПоОтбору(ЭлементПоиска);
		Если ПустаяСтрока(СтрокаПоискаПоля) Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаПоиска = СтрокаПоиска + ?(ПустаяСтрока(СтрокаПоиска), "", " and ") + СтрокаПоискаПоля;
	КонецЦикла;
	
	СтрокаПорядка = "";
	Для Каждого ПолеПорядка Из Параметры.Порядок Цикл
		Разделитель = СтрНайти(ПолеПорядка, " ");
		Если Разделитель > 0 Тогда
			Направление = СокрЛП(Сред(ПолеПорядка, Разделитель + 1));
			ПолеПорядка = Лев(ПолеПорядка, Разделитель - 1);
		КонецЕсли;
			
		ПолеConfluence = ПолучитьПолеConfluence(ПолеПорядка);
		НапрConfluence = ?(НРег(Направление) = "убыв", "desc", "asc");
		Если НЕ ЗначениеЗаполнено(ПолеConfluence) Тогда
			Продолжить;
		КонецЕсли;
		
		СтрокаПорядка = СтрокаПорядка +
			?(ПустаяСтрока(СтрокаПорядка), "", ", ") +
			СтрШаблон("%1 %2", ПолеConfluence, НапрConfluence);
	КонецЦикла;
	СтрокаПорядка = ?(ПустаяСтрока(СтрокаПорядка), "", " order by ") + СтрокаПорядка;
	
	Возврат СтрокаПоиска + СтрокаПорядка;
КонецФункции

Функция СформироватьСтрокуПоискаПоОтбору(знач ЭлементПоиска)
	
	ТекстПоиска = "";
	
	Если НЕ ТипЗнч(ЭлементПоиска) = Тип("Структура") Тогда
		Возврат ТекстПоиска;
	КонецЕсли;
	
	ТипНастройки = СвойствоСтруктуры(ЭлементПоиска, "type", "");
	Если НЕ ЗначениеЗаполнено(ТипНастройки) Тогда
		Возврат ТекстПоиска;
	КонецЕсли;
	
	Если ТипНастройки = "searchgroup" Тогда
		ТипГруппы		= СвойствоСтруктуры(ЭлементПоиска, "ТипГруппы", "");
		ЭлементыГруппы	= СвойствоСтруктуры(ЭлементПоиска, "Элементы", Новый Массив);
		
		Для Каждого ВложеннаяНастройка Из ЭлементыГруппы Цикл
			СтрокаПоиска = СформироватьСтрокуПоискаПоОтбору(ВложеннаяНастройка);
			Если ПустаяСтрока(СтрокаПоиска) Тогда
				Продолжить;
			КонецЕсли;
			
			СтрСоединение = ?(ТипГруппы = ТипГруппыЭлементовОтбораКомпоновкиДанных.ГруппаИли, " or ", " and ");
			
			ТекстПоиска = ТекстПоиска + ?(ПустаяСтрока(ТекстПоиска), "", СтрСоединение) + СтрокаПоиска;
		КонецЦикла;
	ИначеЕсли ТипНастройки = "searchelement" Тогда
		ПолеСравнения		= СвойствоСтруктуры(ЭлементПоиска, "Поле", "");
		УсловиеСравнения	= СвойствоСтруктуры(ЭлементПоиска, "ВидСравнения", Неопределено);
		ЗначениеСравнения	= СвойствоСтруктуры(ЭлементПоиска, "Значение", "");
		
		ПолеConfluence		= ПолучитьПолеConfluence(ПолеСравнения);
		ЗначениеСравнения	= ЗначениеВСтроку(ЗначениеСравнения, ПолеConfluence);
		
		Если НЕ ТипЗнч(УсловиеСравнения) = Тип("ВидСравненияКомпоновкиДанных") Тогда
			Возврат ТекстПоиска;
		ИначеЕсли ВидСравненияНеПоддерживается(УсловиеСравнения) Тогда
			Возврат ТекстПоиска;
		ИначеЕсли НЕ ЗначениеЗаполнено(ПолеConfluence) Тогда
			Возврат ТекстПоиска;
		КонецЕсли;
		
		Если УсловиеСравнения = ВидСравненияКомпоновкиДанных.Больше Тогда
			ТекстУсловия = ">" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.БольшеИлиРавно Тогда
			ТекстУсловия = ">=" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.ВСписке Тогда
			ТекстУсловия = " in (" + ЗначениеСравнения + ")";
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.Меньше Тогда
			ТекстУсловия = "<" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.МеньшеИлиРавно Тогда
			ТекстУсловия = "<=" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НачинаетсяС Тогда
			ТекстУсловия = "=" + ЗначениеСравнения + "*";
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеВСписке Тогда
			ТекстУсловия = " not in (" + ЗначениеСравнения + ")";
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеНачинаетсяС Тогда
			ТекстУсловия = "!=" + ЗначениеСравнения + "*";
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеРавно Тогда
			ТекстУсловия = "!=" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеСодержит Тогда
			Если СтрНайти("title, text", ПолеConfluence) = 0 Тогда
				ВызватьИсключение СтрШаблон(НСтр("ru='Вид сравнения ""Не содержит"" не может быть использован с полем ""%1""'"), ПолеСравнения);
			КонецЕсли;
			
			ТекстУсловия = "!~" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.Равно Тогда
			ТекстУсловия = "=" + ЗначениеСравнения;
		ИначеЕсли УсловиеСравнения = ВидСравненияКомпоновкиДанных.Содержит Тогда
			Если СтрНайти("title, text", ПолеConfluence) = 0 Тогда
				ВызватьИсключение СтрШаблон(НСтр("ru='Вид сравнения ""Содержит"" не может быть использован с полем ""%1""'"), ПолеСравнения);
			КонецЕсли;
			ТекстУсловия = "~" + ЗначениеСравнения;
		Иначе 
			ТекстУсловия = "";
		КонецЕсли;
		
		Если ПустаяСтрока(ТекстУсловия) Тогда
			Возврат ТекстПоиска;
		КонецЕсли;
		
		ТекстПоиска = ПолеConfluence + ТекстУсловия;
	КонецЕсли;
	
	Возврат "(" + ТекстПоиска + ")";
	
КонецФункции

Функция ПолучитьПолеConfluence(знач ПолеПоиска)
	НРегПолеПоиска = НРег(ПолеПоиска);
	
	Если НРегПолеПоиска = "виерархии" Тогда
		ПолеConfluence = "ancestor";
	ИначеЕсли НРегПолеПоиска = "родитель" Тогда
		ПолеConfluence = "parent";
	ИначеЕсли НРегПолеПоиска = "заголовок" Тогда
		ПолеConfluence = "title";
	ИначеЕсли НРегПолеПоиска = "текст" Тогда
		ПолеConfluence = "text";
	ИначеЕсли НРегПолеПоиска = "датасоздания" Тогда
		ПолеConfluence = "created";
	ИначеЕсли НРегПолеПоиска = "датаизменения" Тогда
		ПолеConfluence = "lastmodified";
	ИначеЕсли НРегПолеПоиска = "пространство" Тогда
		ПолеConfluence = "space";
	ИначеЕсли НРегПолеПоиска = "типданных" Тогда
		ПолеConfluence = "type";
	Иначе	
		ПолеConfluence = "";
	КонецЕсли;
	
	Возврат ПолеConfluence;
КонецФункции

Функция ПредставлениеТипаДанныхПоСсылке(знач ТипДанных)
	Если ТипДанных = ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Статья") Тогда
		Возврат "page";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.ЗаписьБлога") Тогда
		Возврат "blogpost";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Комментарий") Тогда
		Возврат "comment";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Вложение") Тогда
		Возврат "attachment";
	ИначеЕсли ТипДанных = ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Пространство") Тогда
		Возврат "space";
	Иначе
		Возврат "";
	КонецЕсли;
КонецФункции

Функция ВидСравненияНеПоддерживается(знач УсловиеСравнения)
	Возврат УсловиеСравнения = ВидСравненияКомпоновкиДанных.ВИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеВИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.ВСпискеПоИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеВСпискеПоИерархии
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.Заполнено
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеЗаполнено
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.Подобно
		ИЛИ УсловиеСравнения = ВидСравненияКомпоновкиДанных.НеПодобно;
КонецФункции

#КонецОбласти
 
#Область СлужебныеПроцедурыИФункции_ПодготовкаДанных

Функция ЗаменитьСпецСимволыHTML(знач ЗначениеСтроки)
	МассивЗамен = Новый Соответствие;
	МассивЗамен.Вставить("&amp;", "&");
	МассивЗамен.Вставить("&lt;", "<");
	МассивЗамен.Вставить("&gt;", ">");
	МассивЗамен.Вставить("&quot;", """");
	МассивЗамен.Вставить("&#39;", "'");
	
	СтрИсходник = ЗначениеСтроки;
	Для Каждого КлючИЗначение Из МассивЗамен Цикл
		СтрИсходник = СтрЗаменить(СтрИсходник, КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат СтрИсходник;
КонецФункции

Функция ФорматироватьСтроку(знач ЗначениеСтроки)
	ЗначениеСтроки = ЗаменитьСпецСимволыHTML(ЗначениеСтроки);
	Если СтрНайти(ЗначениеСтроки, "@@@hl@@@") = 0 Тогда
		Возврат ЗначениеСтроки;
	КонецЕсли;
	
	МассивПодстрок = СтроковыеФункцииКлиентСервер.РазложитьСтрокуВМассивПодстрок(ЗначениеСтроки, "@@@hl@@@", Истина, Ложь);
	
	МассивПредставление = Новый Массив;
	Для Каждого Подстрока Из МассивПодстрок Цикл
		СтрОкончание	= СтрНайти(Подстрока, "@@@endhl@@@");
		НачалоСтроки	= Лев(Подстрока, СтрОкончание-1);
		ОстатокСтроки	= СтрЗаменить(Сред(Подстрока, СтрОкончание), "@@@endhl@@@", "");
		
		Если СтрОкончание > 0 Тогда
			МассивПредставление.Добавить(Новый ФорматированнаяСтрока(НачалоСтроки, Новый Шрифт(,, Истина)));
		Иначе
			МассивПредставление.Добавить(НачалоСтроки);
		КонецЕсли;
		
		МассивПредставление.Добавить(ОстатокСтроки);
	КонецЦикла;
	
	Возврат Новый ФорматированнаяСтрока(МассивПредставление);
КонецФункции

Функция ЗначениеВСтроку(знач ЗначениеСравнения, знач ПолеConfluence = "")
	ТипЗначенияСравнения = ТипЗнч(ЗначениеСравнения);
	Если ТипЗначенияСравнения = Тип("Строка") Тогда
		Возврат """" + ЗначениеСравнения + """";
	ИначеЕсли ТипЗначенияСравнения = Тип("Массив") ИЛИ ТипЗначенияСравнения = Тип("ФиксированныйМассив") Тогда  
		СтрРезультат = "";
		Для Каждого ЗначениеМассива Из ЗначениеСравнения Цикл
			СтрРезультат = СтрРезультат + ?(ПустаяСтрока(СтрРезультат), "", ", ") + ЗначениеВСтроку(ЗначениеМассива, ПолеConfluence);
		КонецЦикла;
		
		Возврат СтрРезультат;
	ИначеЕсли ТипЗначенияСравнения = Тип("СписокЗначений") Тогда  
		СтрРезультат = "";
		Для Каждого ЭлементСписка Из ЗначениеСравнения Цикл
			СтрРезультат = СтрРезультат + ?(ПустаяСтрока(СтрРезультат), "", ", ") + ЗначениеВСтроку(ЭлементСписка.Значение, ПолеConfluence);
		КонецЦикла;
		
		Возврат СтрРезультат;
	ИначеЕсли ТипЗначенияСравнения = Тип("Число") Тогда  
		Возврат Формат(ЗначениеСравнения, "ЧН=0; ЧГ=");
	ИначеЕсли ТипЗначенияСравнения = Тип("Дата") Тогда  
		Возврат """" + Формат(ЗначениеСравнения, "ДФ='yyyy/MM/dd HH:mm'") + """";
	ИначеЕсли ТипЗначенияСравнения = Тип("Булево") Тогда
		Возврат Формат(ЗначениеСравнения, "БЛ=false; БИ=true");
	ИначеЕсли ТипЗначенияСравнения = Тип("ПеречислениеСсылка.ТипыДанныхConfluence") Тогда
		Возврат ПредставлениеТипаДанныхПоСсылке(ЗначениеСравнения);
	Иначе
		Попытка
			Возврат Строка(ЗначениеСравнения);
		Исключение
			ВызватьИсключение СтрШаблон(НСтр("ru='Тип данных ""%1"" не поддерживается.'"), Строка(ТипЗначенияСравнения));
		КонецПопытки;
	КонецЕсли;
КонецФункции

Функция СтатусВСтроку(знач Статус)
	НРегСтатус = НРег(Статус);
	Если НРегСтатус = "удалена" Тогда
		СтрокаСтатус = "trashed";
	ИначеЕсли НРегСтатус = "устарела" Тогда
		СтрокаСтатус = "historical";
	ИначеЕсли НРегСтатус = "черновик" Тогда
		СтрокаСтатус = "draft";
	ИначеЕсли НРегСтатус = "текущая" Тогда
		СтрокаСтатус = "current";
	Иначе
		СтрокаСтатус = "";
	КонецЕсли;
	
	Возврат СтрокаСтатус;
КонецФункции
	
Функция ДатаИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат Дата(1, 1, 1);
	КонецЕсли;
	
	// "yyyy/MM/dd HH:mm" "yyyy-MM-dd HH:mm" "yyyy/MM/dd" "yyyy-MM-dd"
	ЗначГод		= СтрокаВЧисло(Сред(ЗначениеСвойства, 1, 4));
	ЗначМесяц	= СтрокаВЧисло(Сред(ЗначениеСвойства, 6, 2));
	ЗначДата		= СтрокаВЧисло(Сред(ЗначениеСвойства, 9, 2));
	ЗначЧас		= СтрокаВЧисло(Сред(ЗначениеСвойства, 12, 2));
	ЗначМин		= СтрокаВЧисло(Сред(ЗначениеСвойства, 15, 2));
	
	Возврат Дата(ЗначГод, ЗначМесяц, ЗначДата, ЗначЧас, ЗначМин, 0);
КонецФункции

Функция ЧислоИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат 0;
	КонецЕсли;
	
	Возврат СтрокаВЧисло(ЗначениеСвойства);
КонецФункции

Функция БулевоИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат Ложь;
	КонецЕсли;
	
	Возврат ?(ЗначениеСвойства = "true", Истина, Ложь);
КонецФункции

Функция ТипДанныхИзЗначения(знач Соответствие, знач ПутьКлюча)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.ПустаяСсылка");
	КонецЕсли;
	
	НРегЗначениеСвойства = НРег(ЗначениеСвойства);
	Если НРегЗначениеСвойства = "page" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Статья");
	ИначеЕсли НРегЗначениеСвойства = "blogpost" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.ЗаписьБлога");
	ИначеЕсли НРегЗначениеСвойства = "comment" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Комментарий");
	ИначеЕсли НРегЗначениеСвойства = "attachment" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Вложение");
	ИначеЕсли НРегЗначениеСвойства = "space" Тогда
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.Пространство");
	Иначе
		Возврат ПредопределенноеЗначение("Перечисление.ТипыДанныхConfluence.ПустаяСсылка");
	КонецЕсли;
КонецФункции

Функция АдресСсылкиИзЗначения(знач Соответствие, знач ПутьКлюча, знач ПутьКСерверу)
	ЗначениеСвойства = СвойствоСоответствия(Соответствие, ПутьКлюча, Неопределено);
	Если ЗначениеСвойства = Неопределено Тогда
		Возврат "";
	КонецЕсли;
	
	БезРазделителя = (СтрЗаканчиваетсяНа(ПутьКСерверу, "/") ИЛИ СтрНачинаетсяС(ЗначениеСвойства, "/"));
	
	Возврат ПутьКСерверу + ?(БезРазделителя, "", "/") + ЗначениеСвойства;
КонецФункции

Функция СтрокаВЧисло(знач СтрЗначение)
	Возврат СтроковыеФункцииКлиентСервер.СтрокаВЧисло(СтрЗначение);
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции_Статья

Функция СтруктураКонтента(знач ТипConfluence, знач ТипДанных)
	СтруктураЭлемента = Новый Структура;
	СтруктураЭлемента.Вставить("type"			, ТипConfluence);
	СтруктураЭлемента.Вставить("ТипДанных"		, ТипДанных);
	СтруктураЭлемента.Вставить("Тело"			, Новый Массив);

	Возврат СтруктураЭлемента;
КонецФункции

Функция СформироватьHTMLПараметры(знач Параметры)
	Если НЕ ТипЗнч(Параметры) = Тип("Соответствие") Тогда
		Возврат "";
	КонецЕсли;
	
	СтрокаHTML = "";
	Для Каждого КлючИЗначение Из Параметры Цикл
		СтрокаHTML = СтрокаHTML + СтрШаблон(" %1=""%2""", КлючИЗначение.Ключ, КлючИЗначение.Значение);
	КонецЦикла;
	
	Возврат СтрокаHTML;
КонецФункции

Функция ПодготовитьТекстHTMLДляВставки(знач Текст)
	// удалим переносы строк
	Текст = СтрЗаменить(Текст, Символы.ПС, "");
	
	// обработаем br
	Текст = СтрЗаменить(Текст, "<br>", "<br/>");
	
	Возврат Текст;
КонецФункции

Функция ПодготовитьТекстДляВставки(знач Текст)
	Текст = ?(НЕ ТипЗнч(Текст) = Тип("Строка") И НЕ ТипЗнч(Текст) = Тип("ФорматированнаяСтрока"), Строка(Текст), Текст);	
	
	ФорматированнаяСтрока = Новый ФорматированнаяСтрока(Текст);
	
	ФорматированныйДокумент = Новый ФорматированныйДокумент;
	ФорматированныйДокумент.УстановитьФорматированнуюСтроку(ФорматированнаяСтрока);
	
	ТекстHTML	= "";
	Вложения	= Новый Структура;
	ФорматированныйДокумент.ПолучитьHTML(ТекстHTML, Вложения);
	
	СтрНачало		= СтрНайти(ТекстHTML, "<body>");
	СтрОкончание	= СтрНайти(ТекстHTML, "</body>");
	ТекстHTML		= Сред(ТекстHTML, СтрНачало + 6, СтрОкончание - СтрНачало - 6);
	
	Возврат ПодготовитьТекстHTMLДляВставки(ТекстHTML);
КонецФункции

Функция СтруктураЭлементаСтатьи(знач Тег, знач Параметры = Неопределено, знач Текст = "", знач Элементы = Неопределено)
	Если НЕ ТипЗнч(Параметры) = Тип("Соответствие") Тогда
		Параметры = Новый Соответствие;
	КонецЕсли;
	Если НЕ ТипЗнч(Элементы) = Тип("Массив") Тогда
		Элементы = Новый Массив;
	КонецЕсли;
	
	СтруктураЭлемента = Новый Структура;
	СтруктураЭлемента.Вставить("ТегHTML"	, Тег);
	СтруктураЭлемента.Вставить("Параметры"	, Параметры);
	СтруктураЭлемента.Вставить("Текст"		, Текст);
	СтруктураЭлемента.Вставить("Элементы"	, Элементы);
	
	Возврат СтруктураЭлемента;
КонецФункции

#КонецОбласти

#Область СлужебныеПроцедурыИФункции

Процедура ПроверитьПараметры(СтруктураПараметры, знач ПараметрыПоУмолчанию)
	Если НЕ ТипЗнч(СтруктураПараметры) = Тип("Структура") Тогда
		СтруктураПараметры = Новый Структура;
	КонецЕсли;
	
	Для Каждого КлючИЗначение Из ПараметрыПоУмолчанию Цикл
		ЗначениеПараметра = СвойствоСтруктуры(СтруктураПараметры, КлючИЗначение.Ключ, КлючИЗначение.Значение);
		СтруктураПараметры.Вставить(КлючИЗначение.Ключ, ЗначениеПараметра);
	КонецЦикла;
КонецПроцедуры

Функция ПолучитьТипКонтентаПоРасширению(знач ФорматРасширение, знач ИмяФайла)
	Если НЕ ЗначениеЗаполнено(ФорматРасширение) Тогда
		Файл = Новый Файл(ИмяФайла);
		ФорматРасширение = Файл.Расширение;
		Файл = Неопределено;
	КонецЕсли;
	
	СтрРасширение = "";
	Если ТипЗнч(ФорматРасширение) = Тип("ФорматКартинки") Тогда
		Если ФорматРасширение = ФорматКартинки.BMP Тогда
			СтрРасширение = "bmp";
		ИначеЕсли ФорматРасширение = ФорматКартинки.Icon Тогда
			СтрРасширение = "ico";
		ИначеЕсли ФорматРасширение = ФорматКартинки.GIF Тогда
			СтрРасширение = "gif";
		ИначеЕсли ФорматРасширение = ФорматКартинки.JPEG Тогда
			СтрРасширение = "jpeg";
		ИначеЕсли ФорматРасширение = ФорматКартинки.PNG Тогда
			СтрРасширение = "png";
		ИначеЕсли ФорматРасширение = ФорматКартинки.SVG Тогда
			СтрРасширение = "svg";
		ИначеЕсли ФорматРасширение = ФорматКартинки.TIFF Тогда
			СтрРасширение = "tiff";
		КонецЕсли;
	ИначеЕсли ТипЗнч(ФорматРасширение) = Тип("Строка") Тогда
		СтрРасширение = ФорматРасширение;
	КонецЕсли;
	
	Если СтрНачинаетсяС(СтрРасширение, ".") Тогда
		СтрРасширение = Сред(СтрРасширение, 2);
	КонецЕсли;
	
	НРегРасширение = НРег(СтрРасширение);
	Если НРегРасширение = "bmp" Тогда
		Возврат "image/bmp";
	ИначеЕсли НРегРасширение = "ico" Тогда
		Возврат "image/x-icon";
	ИначеЕсли НРегРасширение = "gif" Тогда
		Возврат "image/gif";
	ИначеЕсли НРегРасширение = "jpeg" ИЛИ НРегРасширение = "jpg" Тогда
		Возврат "image/jpeg";
	ИначеЕсли НРегРасширение = "png" Тогда
		Возврат "image/png";
	ИначеЕсли НРегРасширение = "svg" Тогда
		Возврат "image/svg+xml";
	ИначеЕсли НРегРасширение = "tiff" Тогда
		Возврат "image/tiff";
	Иначе 
		Возврат "application/octet-stream"; 
	КонецЕсли;
КонецФункции

Функция ПолучитьСтрокуJSON(знач ОбъектДанных)
	ЗаписьJSON = Новый ЗаписьJSON;
	ЗаписьJSON.УстановитьСтроку();
	ЗаписьJSON.ПроверятьСтруктуру = Ложь;
	ЗаписатьJSON(ЗаписьJSON, ОбъектДанных);
	Возврат ЗаписьJSON.Закрыть();	
КонецФункции

Функция СтрокаПараметровПолучитьПространства(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = ПараметрыПолучитьПространства();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	СтрокаПараметры		= "";
	СтрокаСоединение	= "";
	
	Если ПараметрыЗапроса.Общие = Истина Тогда
		СтрокаПараметры		= СтрокаПараметры + СтрокаСоединение + "type=global";
		СтрокаСоединение	= "&";
	ИначеЕсли ПараметрыЗапроса.Общие = Ложь Тогда
		СтрокаПараметры		= СтрокаПараметры + СтрокаСоединение + "type=personal";
		СтрокаСоединение	= "&";
	КонецЕсли;
	
	Если ПараметрыЗапроса.Действующие = Истина Тогда
		СтрокаПараметры		= СтрокаПараметры + СтрокаСоединение + "status=current";
		СтрокаСоединение	= "&";
	ИначеЕсли ПараметрыЗапроса.Действующие = Ложь Тогда
		СтрокаПараметры		= СтрокаПараметры + СтрокаСоединение + "status=archived";
		СтрокаСоединение	= "&";
	КонецЕсли;
	
	Если НЕ ПустаяСтрока(ПараметрыЗапроса.Метка) Тогда
		СтрокаПараметры		= СтрокаПараметры + СтрокаСоединение + "label=" + ПараметрыЗапроса.Метка;
		СтрокаСоединение	= "&";
	КонецЕсли;
	
	Если ПараметрыЗапроса.Избранное = Истина Тогда
		СтрокаПараметры		= СтрокаПараметры + СтрокаСоединение + "favourite=true";
		СтрокаСоединение	= "&";
	КонецЕсли;
	
	Возврат СтрокаПараметры;
КонецФункции

Функция СтрокаПараметровПоиск(знач ПараметрыЗапроса)
	ПараметрыПоУмолчанию = ПараметрыПоиска();
	ПроверитьПараметры(ПараметрыЗапроса, ПараметрыПоУмолчанию);
	
	Возврат СтрШаблон("&start=%1&limit=%2&includeArchivedSpaces=%3",
		ЗначениеВСтроку(ПараметрыЗапроса.Начало-1),
		ЗначениеВСтроку(ПараметрыЗапроса.Размер),
		ЗначениеВСтроку(ПараметрыЗапроса.Архив));
КонецФункции

Функция ПолучитьСоединениеHTTP(знач Настройки)
	ЗащищенноеСоединение = ?(Настройки.ЗащищенноеСоединение, Новый ЗащищенноеСоединениеOpenSSL, Неопределено);
	Возврат Новый HTTPСоединение(Настройки.Сервер,,,,,, ЗащищенноеСоединение);
КонецФункции

Функция СоответствиеИзОтвета(знач ОтветHTTP)
	ТелоЗапроса = ОтветHTTP.ПолучитьТелоКакСтроку(КодировкаТекста.UTF8);
	
	ЧтениеJSON = Новый ЧтениеJSON;
	ЧтениеJSON.УстановитьСтроку(ТелоЗапроса);
	
	Возврат ПрочитатьJSON(ЧтениеJSON, Истина);
КонецФункции

Функция ПолучитьЗаголовки(знач Настройки)
	Заголовки = Новый Соответствие;
	Заголовки.Вставить("Content-Type"	, "application/json");
	Заголовки.Вставить("Authorization"	, "Basic " + Настройки.СтрокаАвторизации);
	
	Возврат Заголовки;
КонецФункции

// Возвращает значение свойства структуры. см. ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры
//
Функция СвойствоСтруктуры(знач Структура, знач Ключ, знач ПоУмолчанию = Неопределено)
	Возврат ОбщегоНазначенияКлиентСервер.СвойствоСтруктуры(Структура, Ключ, ПоУмолчанию);
КонецФункции

// Возвращает значение свойства соответствия. см. ОбщегоНазначенияПТБКлиентСервер.СвойствоСоответствия
//
Функция СвойствоСоответствия(знач Соответствие, знач ПутьКлюча, знач ПоУмолчанию = Неопределено)
	Возврат ОбщегоНазначенияПТБКлиентСервер.СвойствоСоответствия(Соответствие, ПутьКлюча, ПоУмолчанию);
КонецФункции

#КонецОбласти
